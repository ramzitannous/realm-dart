// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Add a callback that will be invoked every time the view of this file is updated.
///
/// This callback is guaranteed to be invoked before any object or collection change
/// notifications for this realm are delivered.
///
/// @return a registration token used to remove the callback.
@ffi.Native<
    ffi.Pointer<realm_callback_token_t> Function(
        ffi.Pointer<realm_t>, realm_on_realm_change_func_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(symbol: 'realm_add_realm_changed_callback')
external ffi.Pointer<realm_callback_token_t> realm_add_realm_changed_callback(
  ffi.Pointer<realm_t> arg0,
  realm_on_realm_change_func_t arg1,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Add a callback that will be invoked the first time that the given realm is refreshed to the version which is the
/// latest version at the time when this is called.
/// @return a refresh token to remove the callback
@ffi.Native<
    ffi.Pointer<realm_refresh_callback_token_t> Function(
        ffi.Pointer<realm_t>, realm_on_realm_refresh_func_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(symbol: 'realm_add_realm_refresh_callback')
external ffi.Pointer<realm_refresh_callback_token_t> realm_add_realm_refresh_callback(
  ffi.Pointer<realm_t> arg0,
  realm_on_realm_refresh_func_t arg1,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Add a callback that will be invoked every time the schema of this realm is changed.
///
/// @return a registration token used to remove the callback.
@ffi.Native<
    ffi.Pointer<realm_callback_token_t> Function(
        ffi.Pointer<realm_t>, realm_on_schema_change_func_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(symbol: 'realm_add_schema_changed_callback')
external ffi.Pointer<realm_callback_token_t> realm_add_schema_changed_callback(
  ffi.Pointer<realm_t> arg0,
  realm_on_schema_change_func_t arg1,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Run a named MongoDB Realm function.
///
/// @param serialized_ejson_args The arguments array to invoke the function with,
/// serialized as an Extended JSON string.
/// @param service_name The name of the remote service whose system function to call. Can be null,
/// in which case the called function is expected to be a user function.
/// @return true, if no error occurred.
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<realm_user_t>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
        realm_return_string_func_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(symbol: 'realm_app_call_function')
external bool realm_app_call_function(
  ffi.Pointer<realm_app_t> arg0,
  ffi.Pointer<realm_user_t> arg1,
  ffi.Pointer<ffi.Char> function_name,
  ffi.Pointer<ffi.Char> serialized_ejson_args,
  ffi.Pointer<ffi.Char> service_name,
  realm_return_string_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Create a new app configuration.
///
/// @param app_id The MongoDB Realm app id.
/// @param http_transport The HTTP transport used to make network calls.
@ffi.Native<ffi.Pointer<realm_app_config_t> Function(ffi.Pointer<ffi.Char>, ffi.Pointer<realm_http_transport_t>)>(symbol: 'realm_app_config_new')
external ffi.Pointer<realm_app_config_t> realm_app_config_new(
  ffi.Pointer<ffi.Char> app_id,
  ffi.Pointer<realm_http_transport_t> http_transport,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_app_config_t>, ffi.Pointer<ffi.Char>)>(symbol: 'realm_app_config_set_base_url')
external void realm_app_config_set_base_url(
  ffi.Pointer<realm_app_config_t> arg0,
  ffi.Pointer<ffi.Char> arg1,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_app_config_t>, ffi.Pointer<ffi.Char>)>(symbol: 'realm_app_config_set_bundle_id')
external void realm_app_config_set_bundle_id(
  ffi.Pointer<realm_app_config_t> config,
  ffi.Pointer<ffi.Char> bundle_id,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_app_config_t>, ffi.Uint64)>(symbol: 'realm_app_config_set_default_request_timeout')
external void realm_app_config_set_default_request_timeout(
  ffi.Pointer<realm_app_config_t> arg0,
  int ms,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_app_config_t>, ffi.Pointer<ffi.Char>)>(symbol: 'realm_app_config_set_device_name')
external void realm_app_config_set_device_name(
  ffi.Pointer<realm_app_config_t> config,
  ffi.Pointer<ffi.Char> device_name,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_app_config_t>, ffi.Pointer<ffi.Char>)>(symbol: 'realm_app_config_set_device_version')
external void realm_app_config_set_device_version(
  ffi.Pointer<realm_app_config_t> config,
  ffi.Pointer<ffi.Char> device_version,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_app_config_t>, ffi.Pointer<ffi.Char>)>(symbol: 'realm_app_config_set_framework_name')
external void realm_app_config_set_framework_name(
  ffi.Pointer<realm_app_config_t> config,
  ffi.Pointer<ffi.Char> framework_name,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_app_config_t>, ffi.Pointer<ffi.Char>)>(symbol: 'realm_app_config_set_framework_version')
external void realm_app_config_set_framework_version(
  ffi.Pointer<realm_app_config_t> config,
  ffi.Pointer<ffi.Char> framework_version,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_app_config_t>, ffi.Pointer<ffi.Char>)>(symbol: 'realm_app_config_set_platform_version')
external void realm_app_config_set_platform_version(
  ffi.Pointer<realm_app_config_t> arg0,
  ffi.Pointer<ffi.Char> arg1,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_app_config_t>, ffi.Pointer<ffi.Char>)>(symbol: 'realm_app_config_set_sdk')
external void realm_app_config_set_sdk(
  ffi.Pointer<realm_app_config_t> config,
  ffi.Pointer<ffi.Char> sdk,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_app_config_t>, ffi.Pointer<ffi.Char>)>(symbol: 'realm_app_config_set_sdk_version')
external void realm_app_config_set_sdk_version(
  ffi.Pointer<realm_app_config_t> arg0,
  ffi.Pointer<ffi.Char> arg1,
);

/// Create realm_app_t* instance given a valid realm configuration and sync client configuration.
///
/// @return A non-null pointer if no error occurred.
@ffi.Native<ffi.Pointer<realm_app_t> Function(ffi.Pointer<realm_app_config_t>, ffi.Pointer<realm_sync_client_config_t>)>(symbol: 'realm_app_create')
external ffi.Pointer<realm_app_t> realm_app_create(
  ffi.Pointer<realm_app_config_t> arg0,
  ffi.Pointer<realm_sync_client_config_t> arg1,
);

/// Create cached realm_app_t* instance given a valid realm configuration and sync client configuration.
///
/// @return A non-null pointer if no error occurred.
@ffi.Native<ffi.Pointer<realm_app_t> Function(ffi.Pointer<realm_app_config_t>, ffi.Pointer<realm_sync_client_config_t>)>(symbol: 'realm_app_create_cached')
external ffi.Pointer<realm_app_t> realm_app_create_cached(
  ffi.Pointer<realm_app_config_t> arg0,
  ffi.Pointer<realm_sync_client_config_t> arg1,
);

@ffi.Native<ffi.Pointer<realm_app_credentials_t> Function(ffi.Bool)>(symbol: 'realm_app_credentials_new_anonymous')
external ffi.Pointer<realm_app_credentials_t> realm_app_credentials_new_anonymous(
  bool reuse_credentials,
);

@ffi.Native<ffi.Pointer<realm_app_credentials_t> Function(ffi.Pointer<ffi.Char>)>(symbol: 'realm_app_credentials_new_api_key')
external ffi.Pointer<realm_app_credentials_t> realm_app_credentials_new_api_key(
  ffi.Pointer<ffi.Char> api_key,
);

@ffi.Native<ffi.Pointer<realm_app_credentials_t> Function(ffi.Pointer<ffi.Char>)>(symbol: 'realm_app_credentials_new_apple')
external ffi.Pointer<realm_app_credentials_t> realm_app_credentials_new_apple(
  ffi.Pointer<ffi.Char> id_token,
);

@ffi.Native<ffi.Pointer<realm_app_credentials_t> Function(ffi.Pointer<ffi.Char>, realm_string_t)>(symbol: 'realm_app_credentials_new_email_password')
external ffi.Pointer<realm_app_credentials_t> realm_app_credentials_new_email_password(
  ffi.Pointer<ffi.Char> email,
  realm_string_t password,
);

@ffi.Native<ffi.Pointer<realm_app_credentials_t> Function(ffi.Pointer<ffi.Char>)>(symbol: 'realm_app_credentials_new_facebook')
external ffi.Pointer<realm_app_credentials_t> realm_app_credentials_new_facebook(
  ffi.Pointer<ffi.Char> access_token,
);

/// Create Custom Function authentication app credentials.
///
/// @param serialized_ejson_payload The arguments array to invoke the function with,
/// serialized as an Extended JSON string.
/// @return null, if an error occurred.
@ffi.Native<ffi.Pointer<realm_app_credentials_t> Function(ffi.Pointer<ffi.Char>)>(symbol: 'realm_app_credentials_new_function')
external ffi.Pointer<realm_app_credentials_t> realm_app_credentials_new_function(
  ffi.Pointer<ffi.Char> serialized_ejson_payload,
);

@ffi.Native<ffi.Pointer<realm_app_credentials_t> Function(ffi.Pointer<ffi.Char>)>(symbol: 'realm_app_credentials_new_google_auth_code')
external ffi.Pointer<realm_app_credentials_t> realm_app_credentials_new_google_auth_code(
  ffi.Pointer<ffi.Char> auth_code,
);

@ffi.Native<ffi.Pointer<realm_app_credentials_t> Function(ffi.Pointer<ffi.Char>)>(symbol: 'realm_app_credentials_new_google_id_token')
external ffi.Pointer<realm_app_credentials_t> realm_app_credentials_new_google_id_token(
  ffi.Pointer<ffi.Char> id_token,
);

@ffi.Native<ffi.Pointer<realm_app_credentials_t> Function(ffi.Pointer<ffi.Char>)>(symbol: 'realm_app_credentials_new_jwt')
external ffi.Pointer<realm_app_credentials_t> realm_app_credentials_new_jwt(
  ffi.Pointer<ffi.Char> jwt_token,
);

/// Get an existing @a realm_app_credentials_t and return it's json representation
/// Note: the caller must delete the pointer to the string via realm_release
///
/// @return: a non-null ptr to the string representing the json configuration.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<realm_app_credentials_t>)>(symbol: 'realm_app_credentials_serialize_as_json')
external ffi.Pointer<ffi.Char> realm_app_credentials_serialize_as_json(
  ffi.Pointer<realm_app_credentials_t> arg0,
);

/// Deletes a user and all its data from the server.
/// @param app ptr to realm_app
/// @param user ptr to the user to delete
/// @param callback invoked once operation has completed
/// @return True if no error has been recorded, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<realm_user_t>, realm_app_void_completion_func_t, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_app_delete_user')
external bool realm_app_delete_user(
  ffi.Pointer<realm_app_t> app,
  ffi.Pointer<realm_user_t> user,
  realm_app_void_completion_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Run the Email/Password Authentication provider's password reset function.
///
/// @param serialized_ejson_payload The arguments array to invoke the function with,
/// serialized as an Extended JSON string.
/// @return true, if no error occurred.
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<ffi.Char>, realm_string_t, ffi.Pointer<ffi.Char>, realm_app_void_completion_func_t,
        ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(symbol: 'realm_app_email_password_provider_client_call_reset_password_function')
external bool realm_app_email_password_provider_client_call_reset_password_function(
  ffi.Pointer<realm_app_t> arg0,
  ffi.Pointer<ffi.Char> email,
  realm_string_t password,
  ffi.Pointer<ffi.Char> serialized_ejson_payload,
  realm_app_void_completion_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Confirms an email identity with the username/password provider.
/// @param app ptr to realm_app
/// @param token string emailed
/// @param token_id string emailed
/// @param callback invoked once operation has completed
/// @return True if no error has been recorded, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, realm_app_void_completion_func_t, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_app_email_password_provider_client_confirm_user')
external bool realm_app_email_password_provider_client_confirm_user(
  ffi.Pointer<realm_app_t> app,
  ffi.Pointer<ffi.Char> token,
  ffi.Pointer<ffi.Char> token_id,
  realm_app_void_completion_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Registers a new email identity with the username/password provider and send confirmation email.
/// @param app ptr to realm_app
/// @param email identity email
/// @param password associated to the identity
/// @param callback invoked once operation has completed
/// @return True if no error has been recorded, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<ffi.Char>, realm_string_t, realm_app_void_completion_func_t, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_app_email_password_provider_client_register_email')
external bool realm_app_email_password_provider_client_register_email(
  ffi.Pointer<realm_app_t> app,
  ffi.Pointer<ffi.Char> email,
  realm_string_t password,
  realm_app_void_completion_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Re-sends a confirmation email to a user that has registered but not yet confirmed their email address.
/// @param app ptr to realm_app
/// @param email to use
/// @param callback invoked once operation has completed
/// @return True if no error has been recorded, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<ffi.Char>, realm_app_void_completion_func_t, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_app_email_password_provider_client_resend_confirmation_email')
external bool realm_app_email_password_provider_client_resend_confirmation_email(
  ffi.Pointer<realm_app_t> app,
  ffi.Pointer<ffi.Char> email,
  realm_app_void_completion_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Resets the password of an email identity using the password reset token emailed to a user.
/// @param app ptr to realm_app
/// @param password new password to set
/// @param token ptr to token string emailed to the user
/// @param token_id ptr to token_id emailed to the user
/// @return True if no error has been recorded, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, realm_string_t, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, realm_app_void_completion_func_t,
        ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(symbol: 'realm_app_email_password_provider_client_reset_password')
external bool realm_app_email_password_provider_client_reset_password(
  ffi.Pointer<realm_app_t> app,
  realm_string_t password,
  ffi.Pointer<ffi.Char> token,
  ffi.Pointer<ffi.Char> token_id,
  realm_app_void_completion_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Retries the custom confirmation function on a user for a given email.
/// @param app ptr to realm_app
/// @param email email for the user
/// @param callback invoked once operation has completed
/// @return True if no error has been recorded, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<ffi.Char>, realm_app_void_completion_func_t, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_app_email_password_provider_client_retry_custom_confirmation')
external bool realm_app_email_password_provider_client_retry_custom_confirmation(
  ffi.Pointer<realm_app_t> app,
  ffi.Pointer<ffi.Char> email,
  realm_app_void_completion_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Send reset password to the email specified in the parameter passed to the function.
/// @param app ptr to realm_app
/// @param email where to send the reset instructions
/// @param callback invoked once operation has completed
/// @return True if no error has been recorded, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<ffi.Char>, realm_app_void_completion_func_t, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_app_email_password_provider_client_send_reset_password_email')
external bool realm_app_email_password_provider_client_send_reset_password_email(
  ffi.Pointer<realm_app_t> app,
  ffi.Pointer<ffi.Char> email,
  realm_app_void_completion_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Get the list of active users in this @a app.
/// In case of errors this function will return false (errors to be fetched via `realm_get_last_error()`).
/// If data is not copied the function will return true and set  `out_n` with the capacity needed.
/// Data is only copied if the input array has enough capacity, otherwise the needed  array capacity will be set.
///
/// @param out_users A pointer to an array of `realm_user_t*`, which
/// will be populated with the list of active users in the app.
/// Array may be NULL, in this case no data will be copied and `out_n` set if not NULL.
/// @param capacity The maximum number of elements `out_users` can hold.
/// @param out_n The actual number of entries written to `out_users`.
/// May be NULL.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<ffi.Pointer<realm_user_t>>, ffi.Size, ffi.Pointer<ffi.Size>)>(
    symbol: 'realm_app_get_all_users')
external bool realm_app_get_all_users(
  ffi.Pointer<realm_app_t> app,
  ffi.Pointer<ffi.Pointer<realm_user_t>> out_users,
  int capacity,
  ffi.Pointer<ffi.Size> out_n,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<realm_app_t>)>(symbol: 'realm_app_get_app_id')
external ffi.Pointer<ffi.Char> realm_app_get_app_id(
  ffi.Pointer<realm_app_t> arg0,
);

/// Return the current base URL value used by the app. If the realm_app_update_base_url() is called, this
/// value will match the base_url value provided to that function when the update is complete. The value
/// provided by this function is undefined if the realm_app_update_base_url() operation is in progress,
/// since it will likely be the base_url value prior to realm_app_update_base_url() being called.
///
/// @param app ptr to realm_app
/// @return The current base URL string used by the app
///
/// Return value must be manually released with realm_free().
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<realm_app_t>)>(symbol: 'realm_app_get_base_url')
external ffi.Pointer<ffi.Char> realm_app_get_base_url(
  ffi.Pointer<realm_app_t> app,
);

/// Get a cached realm_app_t* instance given an app id. out_app may be null if the app with this id hasn't been
/// previously cached by calling realm_app_create_cached.
///
/// @return true if no error occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<realm_app_t>>)>(symbol: 'realm_app_get_cached')
external bool realm_app_get_cached(
  ffi.Pointer<ffi.Char> app_id,
  ffi.Pointer<ffi.Char> base_url,
  ffi.Pointer<ffi.Pointer<realm_app_t>> out_app,
);

@ffi.Native<ffi.Pointer<realm_user_t> Function(ffi.Pointer<realm_app_t>)>(symbol: 'realm_app_get_current_user')
external ffi.Pointer<realm_user_t> realm_app_get_current_user(
  ffi.Pointer<realm_app_t> arg0,
);

/// Links the currently authenticated user with a new identity, where the identity is defined by the credentia
/// specified as a parameter.
/// @param app ptr to realm_app
/// @param user ptr to the user to link
/// @param credentials sync credentials
/// @param callback invoked once operation has completed
/// @param userdata custom userdata ptr
/// @param userdata_free deleter for custom userdata
/// @return True if no error has been recorded, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<realm_user_t>, ffi.Pointer<realm_app_credentials_t>, realm_app_user_completion_func_t,
        ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(symbol: 'realm_app_link_user')
external bool realm_app_link_user(
  ffi.Pointer<realm_app_t> app,
  ffi.Pointer<realm_user_t> user,
  ffi.Pointer<realm_app_credentials_t> credentials,
  realm_app_user_completion_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Log in a user and asynchronously retrieve a user object. Inform caller via callback once operation completes.
/// @param app ptr to realm_app
/// @param credentials sync credentials
/// @param callback invoked once operation has completed
/// @return True if no error has been recorded, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<realm_app_credentials_t>, realm_app_user_completion_func_t, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_app_log_in_with_credentials')
external bool realm_app_log_in_with_credentials(
  ffi.Pointer<realm_app_t> app,
  ffi.Pointer<realm_app_credentials_t> credentials,
  realm_app_user_completion_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Log out the given user if they are not already logged out.
/// @param app ptr to realm_app
/// @param user ptr to user
/// @param callback invoked once operation has completed
/// @return True if no error has been recorded, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<realm_user_t>, realm_app_void_completion_func_t, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_app_log_out')
external bool realm_app_log_out(
  ffi.Pointer<realm_app_t> app,
  ffi.Pointer<realm_user_t> user,
  realm_app_void_completion_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Logout the current user.
/// @param app ptr to realm_app
/// @param callback invoked once operation has completed
/// @param userdata custom userdata ptr
/// @param userdata_free deleter for custom userdata
/// @return True if no error has been recorded, False otherwise
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_app_t>, realm_app_void_completion_func_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(
    symbol: 'realm_app_log_out_current_user')
external bool realm_app_log_out_current_user(
  ffi.Pointer<realm_app_t> app,
  realm_app_void_completion_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Deregister a device for push notificatons
/// @return True if no error was recorded. False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<realm_user_t>, ffi.Pointer<ffi.Char>, realm_app_void_completion_func_t, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_app_push_notification_client_deregister_device')
external bool realm_app_push_notification_client_deregister_device(
  ffi.Pointer<realm_app_t> arg0,
  ffi.Pointer<realm_user_t> arg1,
  ffi.Pointer<ffi.Char> service_name,
  realm_app_void_completion_func_t arg3,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Register a device for push notifications.
/// @return True if no error was recorded. False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<realm_user_t>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, realm_app_void_completion_func_t,
        ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(symbol: 'realm_app_push_notification_client_register_device')
external bool realm_app_push_notification_client_register_device(
  ffi.Pointer<realm_app_t> arg0,
  ffi.Pointer<realm_user_t> arg1,
  ffi.Pointer<ffi.Char> service_name,
  ffi.Pointer<ffi.Char> registration_token,
  realm_app_void_completion_func_t arg4,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Refreshes the custom data for a specified user.
/// @param app ptr to realm_app
/// @param user ptr to user
/// @param callback invoked once operation has completed
/// @return True if no error has been recorded, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<realm_user_t>, realm_app_void_completion_func_t, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_app_refresh_custom_data')
external bool realm_app_refresh_custom_data(
  ffi.Pointer<realm_app_t> app,
  ffi.Pointer<realm_user_t> user,
  realm_app_void_completion_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Logs out and removes the provided user.
/// @param app ptr to realm_app
/// @param user ptr to the user to remove
/// @param callback invoked once operation has completed
/// @param userdata custom userdata ptr
/// @param userdata_free deleter for custom userdata
/// @return True if no error has been recorded, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<realm_user_t>, realm_app_void_completion_func_t, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_app_remove_user')
external bool realm_app_remove_user(
  ffi.Pointer<realm_app_t> app,
  ffi.Pointer<realm_user_t> user,
  realm_app_void_completion_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Switches the active user with the specified one. The user must exist in the list of all users who have logged into
/// this application.
/// @param app ptr to realm_app
/// @param user ptr to current user
/// @param new_user ptr to the new user to switch
/// @return True if no error has been recorded, False otherwise
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<realm_user_t>, ffi.Pointer<ffi.Pointer<realm_user_t>>)>(symbol: 'realm_app_switch_user')
external bool realm_app_switch_user(
  ffi.Pointer<realm_app_t> app,
  ffi.Pointer<realm_user_t> user,
  ffi.Pointer<ffi.Pointer<realm_user_t>> new_user,
);

/// Get the default realm file path based on the user and partition value in the config.
///
/// @param custom_filename custom name for the realm file itself. Can be null,
/// in which case a default name based on the config will be used.
///
/// Return value must be manually released with realm_free().
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<realm_sync_config_t>, ffi.Pointer<ffi.Char>)>(
    symbol: 'realm_app_sync_client_get_default_file_path_for_realm')
external ffi.Pointer<ffi.Char> realm_app_sync_client_get_default_file_path_for_realm(
  ffi.Pointer<realm_sync_config_t> arg0,
  ffi.Pointer<ffi.Char> custom_filename,
);

/// Get whether there are any active sync sessions for this app.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_app_t>)>(symbol: 'realm_app_sync_client_has_sessions')
external bool realm_app_sync_client_has_sessions(
  ffi.Pointer<realm_app_t> arg0,
);

/// Instruct this app's sync client to immediately reconnect.
/// Useful when the device has been offline and then receives a network reachability update.
///
/// The sync client will always attempt to reconnect eventually, this is just a hint.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_app_t>)>(symbol: 'realm_app_sync_client_reconnect')
external void realm_app_sync_client_reconnect(
  ffi.Pointer<realm_app_t> arg0,
);

/// Wait until the sync client has terminated all sessions and released all realm files
/// it had open.
///
/// WARNING: this is a blocking wait.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_app_t>)>(symbol: 'realm_app_sync_client_wait_for_sessions_to_terminate')
external void realm_app_sync_client_wait_for_sessions_to_terminate(
  ffi.Pointer<realm_app_t> arg0,
);

/// Update the URL used to communicate with the Realm server. This function will update the location
/// information used for http and websocket requests to the server. Once this operation has completed,
/// the new base_url value returned by realm_app_get_base_url() will match the base_url value provided
/// to this function. Any App requests performed while the base URl update is currently in progress
/// will continue to use the original base URL value.
///
/// @param app ptr to realm_app
/// @param base_url The new base URL value to set as the Realm server URL - a null or empty string will
/// use the default base URL value
/// @param callback invoked once operation has completed
/// @return True if no error has been recorded, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<ffi.Char>, realm_app_void_completion_func_t, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_app_update_base_url')
external bool realm_app_update_base_url(
  ffi.Pointer<realm_app_t> app,
  ffi.Pointer<ffi.Char> base_url,
  realm_app_void_completion_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Creates a user API key that can be used to authenticate as the current user.
/// @return True if no error was recorded. False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<realm_user_t>, ffi.Pointer<ffi.Char>, realm_return_apikey_func_t, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_app_user_apikey_provider_client_create_apikey')
external bool realm_app_user_apikey_provider_client_create_apikey(
  ffi.Pointer<realm_app_t> arg0,
  ffi.Pointer<realm_user_t> arg1,
  ffi.Pointer<ffi.Char> name,
  realm_return_apikey_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Deletes a user API key associated with the current user.
/// @return True if no error was recorded. False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<realm_user_t>, realm_object_id_t, realm_app_void_completion_func_t, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_app_user_apikey_provider_client_delete_apikey')
external bool realm_app_user_apikey_provider_client_delete_apikey(
  ffi.Pointer<realm_app_t> arg0,
  ffi.Pointer<realm_user_t> arg1,
  realm_object_id_t id,
  realm_app_void_completion_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Disables a user API key associated with the current user.
/// @return True if no error was recorded. False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<realm_user_t>, realm_object_id_t, realm_app_void_completion_func_t, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_app_user_apikey_provider_client_disable_apikey')
external bool realm_app_user_apikey_provider_client_disable_apikey(
  ffi.Pointer<realm_app_t> arg0,
  ffi.Pointer<realm_user_t> arg1,
  realm_object_id_t id,
  realm_app_void_completion_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Enables a user API key associated with the current user.
/// @return True if no error was recorded. False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<realm_user_t>, realm_object_id_t, realm_app_void_completion_func_t, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_app_user_apikey_provider_client_enable_apikey')
external bool realm_app_user_apikey_provider_client_enable_apikey(
  ffi.Pointer<realm_app_t> arg0,
  ffi.Pointer<realm_user_t> arg1,
  realm_object_id_t id,
  realm_app_void_completion_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Fetches a user API key associated with the current user.
/// @return True if no error was recorded. False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<realm_user_t>, realm_object_id_t, realm_return_apikey_func_t, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_app_user_apikey_provider_client_fetch_apikey')
external bool realm_app_user_apikey_provider_client_fetch_apikey(
  ffi.Pointer<realm_app_t> arg0,
  ffi.Pointer<realm_user_t> arg1,
  realm_object_id_t id,
  realm_return_apikey_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Fetches the user API keys associated with the current user.
/// @return True if no error was recorded. False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<realm_user_t>, realm_return_apikey_list_func_t, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_app_user_apikey_provider_client_fetch_apikeys')
external bool realm_app_user_apikey_provider_client_fetch_apikeys(
  ffi.Pointer<realm_app_t> arg0,
  ffi.Pointer<realm_user_t> arg1,
  realm_return_apikey_list_func_t callback,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// start a new write transaction asynchronously for the realm passed as argument.
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_t>, realm_async_begin_write_func_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t, ffi.Bool,
        ffi.Pointer<ffi.UnsignedInt>)>(symbol: 'realm_async_begin_write')
external bool realm_async_begin_write(
  ffi.Pointer<realm_t> realm,
  realm_async_begin_write_func_t arg1,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
  bool notify_only,
  ffi.Pointer<ffi.UnsignedInt> transaction_id,
);

/// Cancel the transaction referenced by the token passed as argument and set the optional boolean flag in order to
/// inform the caller if the transaction was cancelled.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>, ffi.UnsignedInt, ffi.Pointer<ffi.Bool>)>(symbol: 'realm_async_cancel')
external bool realm_async_cancel(
  ffi.Pointer<realm_t> realm,
  int token,
  ffi.Pointer<ffi.Bool> cancelled,
);

/// commit a transaction asynchronously for the realm passed as argument.
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_t>, realm_async_commit_func_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t, ffi.Bool,
        ffi.Pointer<ffi.UnsignedInt>)>(symbol: 'realm_async_commit')
external bool realm_async_commit(
  ffi.Pointer<realm_t> realm,
  realm_async_commit_func_t arg1,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
  bool allow_grouping,
  ffi.Pointer<ffi.UnsignedInt> transaction_id,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_async_open_task_t>)>(symbol: 'realm_async_open_task_cancel')
external void realm_async_open_task_cancel(
  ffi.Pointer<realm_async_open_task_t> arg0,
);

@ffi.Native<
    ffi.Pointer<realm_async_open_task_progress_notification_token_t> Function(ffi.Pointer<realm_async_open_task_t>, realm_sync_progress_func_t,
        ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(symbol: 'realm_async_open_task_register_download_progress_notifier')
external ffi.Pointer<realm_async_open_task_progress_notification_token_t> realm_async_open_task_register_download_progress_notifier(
  ffi.Pointer<realm_async_open_task_t> arg0,
  realm_sync_progress_func_t arg1,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<realm_async_open_task_t>, realm_async_open_task_completion_func_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(
    symbol: 'realm_async_open_task_start')
external void realm_async_open_task_start(
  ffi.Pointer<realm_async_open_task_t> arg0,
  realm_async_open_task_completion_func_t arg1,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// for debugging only. Enable in realm_dart.cpp
/// RLM_API void realm_dart_gc();
@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Handle, ffi.Pointer<ffi.Void>, ffi.Int)>(symbol: 'realm_attach_finalizer')
external ffi.Pointer<ffi.Void> realm_attach_finalizer(
  Object handle,
  ffi.Pointer<ffi.Void> realmPtr,
  int size,
);

@ffi.Native<ffi.Int32 Function(ffi.Pointer<realm_app_credentials_t>)>(symbol: 'realm_auth_credentials_get_provider')
external int realm_auth_credentials_get_provider(
  ffi.Pointer<realm_app_credentials_t> arg0,
);

/// Begin a read transaction for the Realm file.
///
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>)>(symbol: 'realm_begin_read')
external bool realm_begin_read(
  ffi.Pointer<realm_t> arg0,
);

/// Begin a write transaction for the Realm file.
///
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>)>(symbol: 'realm_begin_write')
external bool realm_begin_write(
  ffi.Pointer<realm_t> arg0,
);

/// Clear all the cached @a realm_app_t* instances in the process.
///
/// @a realm_app_t* instances will need to be disposed with realm_release()
/// for them to be fully destroyed after the cache is cleared.
@ffi.Native<ffi.Void Function()>(symbol: 'realm_clear_cached_apps')
external void realm_clear_cached_apps();

/// Clear the last error on the calling thread.
///
/// Use this if the system has recovered from an error, e.g. by closing the
/// offending Realm and reopening it, freeing up resources, or similar.
///
/// @return True if an error was cleared.
@ffi.Native<ffi.Bool Function()>(symbol: 'realm_clear_last_error')
external bool realm_clear_last_error();

/// Clone a Realm C Wrapper object.
///
/// If the object is not clonable, this function fails with RLM_ERR_NOT_CLONABLE.
///
/// @return A pointer to an object of the same type as the input, or NULL if
/// cloning failed.
@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>(symbol: 'realm_clone')
external ffi.Pointer<ffi.Void> realm_clone(
  ffi.Pointer<ffi.Void> arg0,
);

/// Forcibly close a Realm file.
///
/// Note that this invalidates all Realm instances for the same path.
///
/// The Realm will be automatically closed when the last reference is released,
/// including references to objects within the Realm.
///
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>)>(symbol: 'realm_close')
external bool realm_close(
  ffi.Pointer<realm_t> arg0,
);

/// Get the indices of changes in a collection notification.
///
/// Note: For moves, every `from` index will also be present among deletions, and
/// every `to` index will also be present among insertions.
///
/// This function cannot fail.
///
/// @param out_deletion_indices Where to put the indices of deleted elements
/// (*before* the deletion happened). May be NULL.
/// @param max_deletion_indices The max number of indices to write to @a
/// out_deletion_indices.
/// @param out_insertion_indices Where the put the indices of inserted elements
/// (*after* the insertion happened). May be NULL.
/// @param max_insertion_indices The max number of indices to write to @a
/// out_insertion_indices.
/// @param out_modification_indices Where to put the indices of modified elements
/// (*before* any insertions or deletions of
/// other elements). May be NULL.
/// @param max_modification_indices The max number of indices to write to @a
/// out_modification_indices.
/// @param out_modification_indices_after Where to put the indices of modified
/// elements (*after* any insertions or
/// deletions of other elements). May be
/// NULL.
/// @param max_modification_indices_after The max number of indices to write to
/// @a out_modification_indices_after.
/// @param out_moves Where to put the pairs of indices of moved elements. May be
/// NULL.
/// @param max_moves The max number of pairs to write to @a out_moves.
@ffi.Native<
    ffi.Void Function(ffi.Pointer<realm_collection_changes_t>, ffi.Pointer<ffi.Size>, ffi.Size, ffi.Pointer<ffi.Size>, ffi.Size, ffi.Pointer<ffi.Size>,
        ffi.Size, ffi.Pointer<ffi.Size>, ffi.Size, ffi.Pointer<realm_collection_move_t>, ffi.Size)>(symbol: 'realm_collection_changes_get_changes')
external void realm_collection_changes_get_changes(
  ffi.Pointer<realm_collection_changes_t> arg0,
  ffi.Pointer<ffi.Size> out_deletion_indices,
  int max_deletion_indices,
  ffi.Pointer<ffi.Size> out_insertion_indices,
  int max_insertion_indices,
  ffi.Pointer<ffi.Size> out_modification_indices,
  int max_modification_indices,
  ffi.Pointer<ffi.Size> out_modification_indices_after,
  int max_modification_indices_after,
  ffi.Pointer<realm_collection_move_t> out_moves,
  int max_moves,
);

/// Get the number of various types of changes in a collection notification.
///
/// @param out_num_deletions The number of deletions. May be NULL.
/// @param out_num_insertions The number of insertions. May be NULL.
/// @param out_num_modifications The number of modifications. May be NULL.
/// @param out_num_moves The number of moved elements. May be NULL.
/// @param out_collection_was_cleared a flag to signal if the collection has been cleared. May be NULL
@ffi.Native<
    ffi.Void Function(ffi.Pointer<realm_collection_changes_t>, ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Size>,
        ffi.Pointer<ffi.Bool>)>(symbol: 'realm_collection_changes_get_num_changes')
external void realm_collection_changes_get_num_changes(
  ffi.Pointer<realm_collection_changes_t> arg0,
  ffi.Pointer<ffi.Size> out_num_deletions,
  ffi.Pointer<ffi.Size> out_num_insertions,
  ffi.Pointer<ffi.Size> out_num_modifications,
  ffi.Pointer<ffi.Size> out_num_moves,
  ffi.Pointer<ffi.Bool> out_collection_was_cleared,
);

/// Get the number of various types of changes in a collection notification,
/// suitable for acquiring the change indices as ranges, which is much more
/// compact in memory than getting the individual indices when multiple adjacent
/// elements have been modified.
///
/// @param out_num_deletion_ranges The number of deleted ranges. May be NULL.
/// @param out_num_insertion_ranges The number of inserted ranges. May be NULL.
/// @param out_num_modification_ranges The number of modified ranges. May be
/// NULL.
/// @param out_num_moves The number of moved elements. May be NULL.
@ffi.Native<
        ffi.Void Function(ffi.Pointer<realm_collection_changes_t>, ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Size>)>(
    symbol: 'realm_collection_changes_get_num_ranges')
external void realm_collection_changes_get_num_ranges(
  ffi.Pointer<realm_collection_changes_t> arg0,
  ffi.Pointer<ffi.Size> out_num_deletion_ranges,
  ffi.Pointer<ffi.Size> out_num_insertion_ranges,
  ffi.Pointer<ffi.Size> out_num_modification_ranges,
  ffi.Pointer<ffi.Size> out_num_moves,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<realm_collection_changes_t>,
        ffi.Pointer<realm_index_range_t>,
        ffi.Size,
        ffi.Pointer<realm_index_range_t>,
        ffi.Size,
        ffi.Pointer<realm_index_range_t>,
        ffi.Size,
        ffi.Pointer<realm_index_range_t>,
        ffi.Size,
        ffi.Pointer<realm_collection_move_t>,
        ffi.Size)>(symbol: 'realm_collection_changes_get_ranges')
external void realm_collection_changes_get_ranges(
  ffi.Pointer<realm_collection_changes_t> arg0,
  ffi.Pointer<realm_index_range_t> out_deletion_ranges,
  int max_deletion_ranges,
  ffi.Pointer<realm_index_range_t> out_insertion_ranges,
  int max_insertion_ranges,
  ffi.Pointer<realm_index_range_t> out_modification_ranges,
  int max_modification_ranges,
  ffi.Pointer<realm_index_range_t> out_modification_ranges_after,
  int max_modification_ranges_after,
  ffi.Pointer<realm_collection_move_t> out_moves,
  int max_moves,
);

/// Commit a write transaction.
///
/// @return True if the commit succeeded and no exceptions were thrown.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>)>(symbol: 'realm_commit')
external bool realm_commit(
  ffi.Pointer<realm_t> arg0,
);

/// Vacuum the free space from the realm file, reducing its file size.
///
/// @return True if no exceptions are thrown, false otherwise.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>, ffi.Pointer<ffi.Bool>)>(symbol: 'realm_compact')
external bool realm_compact(
  ffi.Pointer<realm_t> arg0,
  ffi.Pointer<ffi.Bool> did_compact,
);

/// True if automatic change notifications should be generated.
///
/// This function cannot fail.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_config_t>)>(symbol: 'realm_config_get_automatic_change_notifications')
external bool realm_config_get_automatic_change_notifications(
  ffi.Pointer<realm_config_t> arg0,
);

/// Check if realms are cached
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_config_t>)>(symbol: 'realm_config_get_cached')
external bool realm_config_get_cached(
  ffi.Pointer<realm_config_t> arg0,
);

/// True if file format upgrades on open are disabled.
///
/// This function cannot fail.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_config_t>)>(symbol: 'realm_config_get_disable_format_upgrade')
external bool realm_config_get_disable_format_upgrade(
  ffi.Pointer<realm_config_t> arg0,
);

/// Get the encryption key for the realm.
///
/// The output buffer must be at least 64 bytes.
///
/// @returns The length of the encryption key (0 or 64)
@ffi.Native<ffi.Size Function(ffi.Pointer<realm_config_t>, ffi.Pointer<ffi.Uint8>)>(symbol: 'realm_config_get_encryption_key')
external int realm_config_get_encryption_key(
  ffi.Pointer<realm_config_t> arg0,
  ffi.Pointer<ffi.Uint8> out_key,
);

/// Check realm FIFO path
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<realm_config_t>)>(symbol: 'realm_config_get_fifo_path')
external ffi.Pointer<ffi.Char> realm_config_get_fifo_path(
  ffi.Pointer<realm_config_t> arg0,
);

/// Get whether the realm file should be forcibly initialized as a synchronized.
///
/// This function cannot fail.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_config_t>)>(symbol: 'realm_config_get_force_sync_history')
external bool realm_config_get_force_sync_history(
  ffi.Pointer<realm_config_t> arg0,
);

/// Check if realm is configured in memory
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_config_t>)>(symbol: 'realm_config_get_in_memory')
external bool realm_config_get_in_memory(
  ffi.Pointer<realm_config_t> arg0,
);

/// Get maximum number of active versions in the realm file allowed before an
/// exception is thrown.
///
/// This function cannot fail.
@ffi.Native<ffi.Uint64 Function(ffi.Pointer<realm_config_t>)>(symbol: 'realm_config_get_max_number_of_active_versions')
external int realm_config_get_max_number_of_active_versions(
  ffi.Pointer<realm_config_t> arg0,
);

/// Get the path of the realm being opened.
///
/// This function cannot fail.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<realm_config_t>)>(symbol: 'realm_config_get_path')
external ffi.Pointer<ffi.Char> realm_config_get_path(
  ffi.Pointer<realm_config_t> arg0,
);

/// Get the schema for this realm.
///
/// Note: The caller obtains ownership of the returned value, and must manually
/// free it by calling `realm_release()`.
///
/// @return A schema object, or NULL if the schema is not set (empty).
@ffi.Native<ffi.Pointer<realm_schema_t> Function(ffi.Pointer<realm_config_t>)>(symbol: 'realm_config_get_schema')
external ffi.Pointer<realm_schema_t> realm_config_get_schema(
  ffi.Pointer<realm_config_t> arg0,
);

/// Get the schema mode.
///
/// This function cannot fail.
@ffi.Native<ffi.Int32 Function(ffi.Pointer<realm_config_t>)>(symbol: 'realm_config_get_schema_mode')
external int realm_config_get_schema_mode(
  ffi.Pointer<realm_config_t> arg0,
);

/// Get the subset schema mode.
///
/// This function cannot fail.
@ffi.Native<ffi.Int32 Function(ffi.Pointer<realm_config_t>)>(symbol: 'realm_config_get_schema_subset_mode')
external int realm_config_get_schema_subset_mode(
  ffi.Pointer<realm_config_t> arg0,
);

/// Get the schema version of the schema.
///
/// This function cannot fail.
@ffi.Native<ffi.Uint64 Function(ffi.Pointer<realm_config_t>)>(symbol: 'realm_config_get_schema_version')
external int realm_config_get_schema_version(
  ffi.Pointer<realm_config_t> arg0,
);

/// Allocate a new configuration with default options.
@ffi.Native<ffi.Pointer<realm_config_t> Function()>(symbol: 'realm_config_new')
external ffi.Pointer<realm_config_t> realm_config_new();

/// Set the audit interface for the realm (unimplemented).
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_config_t>, ffi.Pointer<ffi.Void>)>(symbol: 'realm_config_set_audit_factory')
external bool realm_config_set_audit_factory(
  ffi.Pointer<realm_config_t> arg0,
  ffi.Pointer<ffi.Void> arg1,
);

/// Allow realm to manage automatically embedded objects when a migration from TopLevel to Embedded takes place.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_config_t>, ffi.Bool)>(symbol: 'realm_config_set_automatic_backlink_handling')
external void realm_config_set_automatic_backlink_handling(
  ffi.Pointer<realm_config_t> arg0,
  bool arg1,
);

/// Automatically generated change notifications (default: true).
///
/// This function cannot fail.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_config_t>, ffi.Bool)>(symbol: 'realm_config_set_automatic_change_notifications')
external void realm_config_set_automatic_change_notifications(
  ffi.Pointer<realm_config_t> arg0,
  bool arg1,
);

/// If 'cached' is false, always return a new Realm instance.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_config_t>, ffi.Bool)>(symbol: 'realm_config_set_cached')
external void realm_config_set_cached(
  ffi.Pointer<realm_config_t> arg0,
  bool cached,
);

/// Set the data initialization function.
///
/// The callback is invoked the first time the schema is created, such that the
/// user can perform one-time initialization of the data in the realm.
///
/// The realm instance passed to the callback is in a write transaction.
///
/// This function cannot fail.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_config_t>, realm_data_initialization_func_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(
    symbol: 'realm_config_set_data_initialization_function')
external void realm_config_set_data_initialization_function(
  ffi.Pointer<realm_config_t> arg0,
  realm_data_initialization_func_t arg1,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Disable file format upgrade on open (default: false).
///
/// If a migration is needed to open the realm file with the provided schema, an
/// error is thrown rather than automatically performing the migration.
///
/// This function cannot fail.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_config_t>, ffi.Bool)>(symbol: 'realm_config_set_disable_format_upgrade')
external void realm_config_set_disable_format_upgrade(
  ffi.Pointer<realm_config_t> arg0,
  bool arg1,
);

/// Set the encryption key for the realm.
///
/// The key must be either 64 bytes long or have length zero (in which case
/// encryption is disabled).
///
/// This function may fail if the encryption key has the wrong length.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_config_t>, ffi.Pointer<ffi.Uint8>, ffi.Size)>(symbol: 'realm_config_set_encryption_key')
external bool realm_config_set_encryption_key(
  ffi.Pointer<realm_config_t> arg0,
  ffi.Pointer<ffi.Uint8> key,
  int key_size,
);

/// Set FIFO path
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_config_t>, ffi.Pointer<ffi.Char>)>(symbol: 'realm_config_set_fifo_path')
external void realm_config_set_fifo_path(
  ffi.Pointer<realm_config_t> arg0,
  ffi.Pointer<ffi.Char> arg1,
);

/// Force the realm file to be initialized as a synchronized realm, even if no
/// sync config is provided (default: false).
///
/// This function cannot fail.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_config_t>, ffi.Bool)>(symbol: 'realm_config_set_force_sync_history')
external void realm_config_set_force_sync_history(
  ffi.Pointer<realm_config_t> arg0,
  bool arg1,
);

/// Configure realm to be in memory
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_config_t>, ffi.Bool)>(symbol: 'realm_config_set_in_memory')
external void realm_config_set_in_memory(
  ffi.Pointer<realm_config_t> arg0,
  bool arg1,
);

/// Set maximum number of active versions in the realm file allowed before an
/// exception is thrown (default: UINT64_MAX).
///
/// This function cannot fail.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_config_t>, ffi.Uint64)>(symbol: 'realm_config_set_max_number_of_active_versions')
external void realm_config_set_max_number_of_active_versions(
  ffi.Pointer<realm_config_t> arg0,
  int arg1,
);

/// Set the migration callback.
///
/// The migration function is called during a migration for schema modes
/// `RLM_SCHEMA_MODE_AUTOMATIC` and `RLM_SCHEMA_MODE_MANUAL`. The callback is
/// invoked with a realm instance before the migration and the realm instance
/// that is currently performing the migration.
///
/// This function cannot fail.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_config_t>, realm_migration_func_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(
    symbol: 'realm_config_set_migration_function')
external void realm_config_set_migration_function(
  ffi.Pointer<realm_config_t> arg0,
  realm_migration_func_t arg1,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Set the path of the realm being opened.
///
/// This function aborts when out of memory, but otherwise cannot fail.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_config_t>, ffi.Pointer<ffi.Char>)>(symbol: 'realm_config_set_path')
external void realm_config_set_path(
  ffi.Pointer<realm_config_t> arg0,
  ffi.Pointer<ffi.Char> path,
);

/// The scheduler which this realm should be bound to (default: NULL).
///
/// If NULL, the realm will be bound to the default scheduler for the current thread.
///
/// This function aborts when out of memory, but otherwise cannot fail.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_config_t>, ffi.Pointer<realm_scheduler_t>)>(symbol: 'realm_config_set_scheduler')
external void realm_config_set_scheduler(
  ffi.Pointer<realm_config_t> arg0,
  ffi.Pointer<realm_scheduler_t> arg1,
);

/// Set the schema object for this realm.
///
/// This does not take ownership of the schema object, and it should be released
/// afterwards.
///
/// This function aborts when out of memory, but otherwise cannot fail.
///
/// @param schema The schema object. May be NULL, which means an empty schema.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_config_t>, ffi.Pointer<realm_schema_t>)>(symbol: 'realm_config_set_schema')
external void realm_config_set_schema(
  ffi.Pointer<realm_config_t> arg0,
  ffi.Pointer<realm_schema_t> schema,
);

/// Set the schema mode.
///
/// This function cannot fail.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_config_t>, ffi.Int32)>(symbol: 'realm_config_set_schema_mode')
external void realm_config_set_schema_mode(
  ffi.Pointer<realm_config_t> arg0,
  int arg1,
);

/// Set schema subset mode
///
/// This function cannot fail
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_config_t>, ffi.Int32)>(symbol: 'realm_config_set_schema_subset_mode')
external void realm_config_set_schema_subset_mode(
  ffi.Pointer<realm_config_t> arg0,
  int arg1,
);

/// Set the schema version of the schema.
///
/// This function cannot fail.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_config_t>, ffi.Uint64)>(symbol: 'realm_config_set_schema_version')
external void realm_config_set_schema_version(
  ffi.Pointer<realm_config_t> arg0,
  int version,
);

/// Set the should-compact-on-launch callback.
///
/// The callback is invoked the first time a realm file is opened in this process
/// to decide whether the realm file should be compacted.
///
/// Note: If another process has the realm file open, it will not be compacted.
///
/// This function cannot fail.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_config_t>, realm_should_compact_on_launch_func_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(
    symbol: 'realm_config_set_should_compact_on_launch_function')
external void realm_config_set_should_compact_on_launch_function(
  ffi.Pointer<realm_config_t> arg0,
  realm_should_compact_on_launch_func_t arg1,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Sync configuration for this realm (default: NULL).
///
/// This function aborts when out of memory, but otherwise cannot fail.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_config_t>, ffi.Pointer<realm_sync_config_t>)>(symbol: 'realm_config_set_sync_config')
external void realm_config_set_sync_config(
  ffi.Pointer<realm_config_t> arg0,
  ffi.Pointer<realm_sync_config_t> arg1,
);

/// The overloaded Realm::convert function offers a way to copy and/or convert a realm.
///
/// The following options are supported:
/// - local -> local (config or path)
/// - local -> sync (config only)
/// - sync -> local (config only)
/// - sync -> sync  (config or path)
/// - sync -> bundlable sync (client file identifier removed)
///
/// Note that for bundled realms it is required that all local changes are synchronized with the
/// server before the copy can be written. This is to be sure that the file can be used as a
/// stating point for a newly installed application. The function will throw if there are
/// pending uploads.
/// /
/// /**
/// Copy or convert a Realm using a config.
///
/// If the file already exists and merge_with_existing is true, data will be copied over object per object.
/// When merging, all classes must have a pk called '_id" otherwise an exception is thrown.
/// If the file exists and merge_with_existing is false, an exception is thrown.
/// If the file does not exist, the realm file will be exported to the new location and if the
/// configuration object contains a sync part, a sync history will be synthesized.
///
/// @param config The realm configuration that should be used to create a copy.
/// This can be a local or a synced Realm, encrypted or not.
/// @param merge_with_existing If this is true and the destination file exists, data will be copied over object by
/// object. Otherwise, if this is false and the destination file exists, an exception is thrown.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>, ffi.Pointer<realm_config_t>, ffi.Bool)>(symbol: 'realm_convert_with_config')
external bool realm_convert_with_config(
  ffi.Pointer<realm_t> realm,
  ffi.Pointer<realm_config_t> config,
  bool merge_with_existing,
);

/// Copy a Realm using a path.
///
/// @param path The path the realm should be copied to. Local realms will remain local, synced
/// realms will remain synced realms.
/// @param encryption_key The optional encryption key for the new realm.
/// @param merge_with_existing If this is true and the destination file exists, data will be copied over object by
/// object.
/// Otherwise, if this is false and the destination file exists, an exception is thrown.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>, ffi.Pointer<ffi.Char>, realm_binary_t, ffi.Bool)>(symbol: 'realm_convert_with_path')
external bool realm_convert_with_path(
  ffi.Pointer<realm_t> realm,
  ffi.Pointer<ffi.Char> path,
  realm_binary_t encryption_key,
  bool merge_with_existing,
);

/// Helper method for making it easier to to convert SDK input to the underlying
/// `realm_key_path_array_t`.
///
/// @return A pointer to the converted key path array. NULL in case of an error.
@ffi.Native<ffi.Pointer<realm_key_path_array_t> Function(ffi.Pointer<realm_t>, realm_class_key_t, ffi.Size, ffi.Pointer<ffi.Pointer<ffi.Char>>)>(
    symbol: 'realm_create_key_path_array')
external ffi.Pointer<realm_key_path_array_t> realm_create_key_path_array(
  ffi.Pointer<realm_t> realm,
  int object_class_key,
  int num_key_paths,
  ffi.Pointer<ffi.Pointer<ffi.Char>> user_key_paths,
);

/// Get a thread-safe reference representing the same underlying object as some
/// API object.
///
/// The thread safe reference can be passed to a different thread and resolved
/// against a different `realm_t` instance, which succeeds if the underlying
/// object still exists.
///
/// The following types can produce thread safe references:
///
/// - `realm_object_t`
/// - `realm_results_t`
/// - `realm_list_t`
/// - `realm_t`
///
/// This does not assume ownership of the object, except for `realm_t`, where the
/// instance is transferred by value, and must be transferred back to the current
/// thread to be used. Note that the `realm_thread_safe_reference_t` object must
/// still be destroyed after having been converted into a `realm_t` object.
///
/// @return A non-null pointer if no exception occurred.
@ffi.Native<ffi.Pointer<realm_thread_safe_reference_t> Function(ffi.Pointer<ffi.Void>)>(symbol: 'realm_create_thread_safe_reference')
external ffi.Pointer<realm_thread_safe_reference_t> realm_create_thread_safe_reference(
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<realm_app_user_apikey_t>, ffi.Pointer<realm_app_error_t>)>(
    symbol: 'realm_dart_apikey_callback')
external void realm_dart_apikey_callback(
  ffi.Pointer<ffi.Void> userdata,
  ffi.Pointer<realm_app_user_apikey_t> apikey,
  ffi.Pointer<realm_app_error_t> error,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<realm_app_user_apikey_t>, ffi.Size, ffi.Pointer<realm_app_error_t>)>(
    symbol: 'realm_dart_apikey_list_callback')
external void realm_dart_apikey_list_callback(
  ffi.Pointer<ffi.Void> userdata,
  ffi.Pointer<realm_app_user_apikey_t> apikey_list,
  int count,
  ffi.Pointer<realm_app_error_t> error,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<realm_thread_safe_reference_t>, ffi.Pointer<realm_async_error_t>)>(
    symbol: 'realm_dart_async_open_task_callback')
external void realm_dart_async_open_task_callback(
  ffi.Pointer<ffi.Void> userdata,
  ffi.Pointer<realm_thread_safe_reference_t> realm,
  ffi.Pointer<realm_async_error_t> error,
);

@ffi.Native<ffi.Pointer<realm_scheduler_t> Function(ffi.Uint64, Dart_Port)>(symbol: 'realm_dart_create_scheduler')
external ffi.Pointer<realm_scheduler_t> realm_dart_create_scheduler(
  int isolateId,
  int port,
);

@ffi.Native<realm_decimal128_t Function(realm_decimal128_t, realm_decimal128_t)>(symbol: 'realm_dart_decimal128_add')
external realm_decimal128_t realm_dart_decimal128_add(
  realm_decimal128_t x,
  realm_decimal128_t y,
);

@ffi.Native<ffi.Int Function(realm_decimal128_t, realm_decimal128_t)>(symbol: 'realm_dart_decimal128_compare_to')
external int realm_dart_decimal128_compare_to(
  realm_decimal128_t x,
  realm_decimal128_t y,
);

/// work-around for Dart FFI issue
@ffi.Native<realm_decimal128_t Function(realm_decimal128_t)>(symbol: 'realm_dart_decimal128_copy')
external realm_decimal128_t realm_dart_decimal128_copy(
  realm_decimal128_t x,
);

@ffi.Native<realm_decimal128_t Function(realm_decimal128_t, realm_decimal128_t)>(symbol: 'realm_dart_decimal128_divide')
external realm_decimal128_t realm_dart_decimal128_divide(
  realm_decimal128_t x,
  realm_decimal128_t y,
);

@ffi.Native<ffi.Bool Function(realm_decimal128_t, realm_decimal128_t)>(symbol: 'realm_dart_decimal128_equal')
external bool realm_dart_decimal128_equal(
  realm_decimal128_t x,
  realm_decimal128_t y,
);

@ffi.Native<realm_decimal128_t Function(ffi.Int64)>(symbol: 'realm_dart_decimal128_from_int64')
external realm_decimal128_t realm_dart_decimal128_from_int64(
  int low,
);

@ffi.Native<realm_decimal128_t Function(ffi.Pointer<ffi.Char>)>(symbol: 'realm_dart_decimal128_from_string')
external realm_decimal128_t realm_dart_decimal128_from_string(
  ffi.Pointer<ffi.Char> string,
);

@ffi.Native<ffi.Bool Function(realm_decimal128_t, realm_decimal128_t)>(symbol: 'realm_dart_decimal128_greater_than')
external bool realm_dart_decimal128_greater_than(
  realm_decimal128_t x,
  realm_decimal128_t y,
);

@ffi.Native<ffi.Bool Function(realm_decimal128_t)>(symbol: 'realm_dart_decimal128_is_nan')
external bool realm_dart_decimal128_is_nan(
  realm_decimal128_t x,
);

@ffi.Native<ffi.Bool Function(realm_decimal128_t, realm_decimal128_t)>(symbol: 'realm_dart_decimal128_less_than')
external bool realm_dart_decimal128_less_than(
  realm_decimal128_t x,
  realm_decimal128_t y,
);

@ffi.Native<realm_decimal128_t Function(realm_decimal128_t, realm_decimal128_t)>(symbol: 'realm_dart_decimal128_multiply')
external realm_decimal128_t realm_dart_decimal128_multiply(
  realm_decimal128_t x,
  realm_decimal128_t y,
);

@ffi.Native<realm_decimal128_t Function()>(symbol: 'realm_dart_decimal128_nan')
external realm_decimal128_t realm_dart_decimal128_nan();

@ffi.Native<realm_decimal128_t Function(realm_decimal128_t)>(symbol: 'realm_dart_decimal128_negate')
external realm_decimal128_t realm_dart_decimal128_negate(
  realm_decimal128_t x,
);

@ffi.Native<realm_decimal128_t Function(realm_decimal128_t, realm_decimal128_t)>(symbol: 'realm_dart_decimal128_subtract')
external realm_decimal128_t realm_dart_decimal128_subtract(
  realm_decimal128_t x,
  realm_decimal128_t y,
);

@ffi.Native<ffi.Int64 Function(realm_decimal128_t)>(symbol: 'realm_dart_decimal128_to_int64')
external int realm_dart_decimal128_to_int64(
  realm_decimal128_t x,
);

@ffi.Native<realm_string_t Function(realm_decimal128_t)>(symbol: 'realm_dart_decimal128_to_string')
external realm_string_t realm_dart_decimal128_to_string(
  realm_decimal128_t x,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>(symbol: 'realm_dart_delete_persistent_handle')
external void realm_dart_delete_persistent_handle(
  ffi.Pointer<ffi.Void> handle,
);

/// implemented for Android only
@ffi.Native<ffi.Pointer<ffi.Char> Function()>(symbol: 'realm_dart_get_bundle_id')
external ffi.Pointer<ffi.Char> realm_dart_get_bundle_id();

@ffi.Native<ffi.Pointer<ffi.Char> Function()>(symbol: 'realm_dart_get_device_name')
external ffi.Pointer<ffi.Char> realm_dart_get_device_name();

@ffi.Native<ffi.Pointer<ffi.Char> Function()>(symbol: 'realm_dart_get_device_version')
external ffi.Pointer<ffi.Char> realm_dart_get_device_version();

/// implemented for iOS and Android only
@ffi.Native<ffi.Pointer<ffi.Char> Function()>(symbol: 'realm_dart_get_files_path')
external ffi.Pointer<ffi.Char> realm_dart_get_files_path();

@ffi.Native<ffi.Uint64 Function()>(symbol: 'realm_dart_get_thread_id')
external int realm_dart_get_thread_id();

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>, realm_http_request_t, ffi.Pointer<ffi.Void>)>(symbol: 'realm_dart_http_request_callback')
external void realm_dart_http_request_callback(
  ffi.Pointer<ffi.Void> userdata,
  realm_http_request_t request,
  ffi.Pointer<ffi.Void> request_context,
);

/// Returns `true` if Realm Core logger was initialized.
@ffi.Native<ffi.Bool Function(ffi.Int32)>(symbol: 'realm_dart_init_core_logger')
external bool realm_dart_init_core_logger(
  int level,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>(symbol: 'realm_dart_initializeDartApiDL')
external void realm_dart_initializeDartApiDL(
  ffi.Pointer<ffi.Void> data,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>(symbol: 'realm_dart_invoke_unlock_callback')
external void realm_dart_invoke_unlock_callback(
  ffi.Pointer<ffi.Void> error,
  ffi.Pointer<ffi.Void> unlockFunc,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function()>(symbol: 'realm_dart_library_version')
external ffi.Pointer<ffi.Char> realm_dart_library_version();

@ffi.Native<ffi.Void Function(ffi.Int32, ffi.Pointer<ffi.Char>)>(symbol: 'realm_dart_log_message_for_testing')
external void realm_dart_log_message_for_testing(
  int level,
  ffi.Pointer<ffi.Char> message,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Handle)>(symbol: 'realm_dart_object_to_persistent_handle')
external ffi.Pointer<ffi.Void> realm_dart_object_to_persistent_handle(
  Object handle,
);

@ffi.Native<ffi.Handle Function(ffi.Pointer<ffi.Void>)>(symbol: 'realm_dart_persistent_handle_to_object')
external Object realm_dart_persistent_handle_to_object(
  ffi.Pointer<ffi.Void> handle,
);

@ffi.Native<ffi.Void Function(Dart_Port)>(symbol: 'realm_dart_release_logger')
external void realm_dart_release_logger(
  int port,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Pointer<realm_app_error_t>)>(symbol: 'realm_dart_return_string_callback')
external void realm_dart_return_string_callback(
  ffi.Pointer<ffi.Void> userdata,
  ffi.Pointer<ffi.Char> serialized_ejson_response,
  ffi.Pointer<realm_app_error_t> error,
);

@ffi.Native<ffi.Void Function(ffi.Uint64, ffi.Pointer<ffi.Void>)>(symbol: 'realm_dart_scheduler_invoke')
external void realm_dart_scheduler_invoke(
  int isolateId,
  ffi.Pointer<ffi.Void> userData,
);

@ffi.Native<ffi.Void Function(ffi.Int32, Dart_Port)>(symbol: 'realm_dart_set_log_level')
external void realm_dart_set_log_level(
  int level,
  int port,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<realm_t>, ffi.Pointer<realm_thread_safe_reference_t>, ffi.Bool)>(
    symbol: 'realm_dart_sync_after_reset_handler_callback')
external bool realm_dart_sync_after_reset_handler_callback(
  ffi.Pointer<ffi.Void> userdata,
  ffi.Pointer<realm_t> before_realm,
  ffi.Pointer<realm_thread_safe_reference_t> after_realm,
  bool did_recover,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<realm_t>)>(symbol: 'realm_dart_sync_before_reset_handler_callback')
external bool realm_dart_sync_before_reset_handler_callback(
  ffi.Pointer<ffi.Void> userdata,
  ffi.Pointer<realm_t> realm,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Pointer<ffi.Char>)>(symbol: 'realm_dart_sync_client_log_callback')
external void realm_dart_sync_client_log_callback(
  ffi.Pointer<ffi.Void> userdata,
  int level,
  ffi.Pointer<ffi.Char> message,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32, ffi.Int32)>(symbol: 'realm_dart_sync_connection_state_changed_callback')
external void realm_dart_sync_connection_state_changed_callback(
  ffi.Pointer<ffi.Void> userdata,
  int old_state,
  int new_state,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<realm_sync_session_t>, realm_sync_error_t)>(symbol: 'realm_dart_sync_error_handler_callback')
external void realm_dart_sync_error_handler_callback(
  ffi.Pointer<ffi.Void> userdata,
  ffi.Pointer<realm_sync_session_t> session,
  realm_sync_error_t error,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>(symbol: 'realm_dart_sync_on_subscription_state_changed_callback')
external void realm_dart_sync_on_subscription_state_changed_callback(
  ffi.Pointer<ffi.Void> userdata,
  int state,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Uint64, ffi.Uint64)>(symbol: 'realm_dart_sync_progress_callback')
external void realm_dart_sync_progress_callback(
  ffi.Pointer<ffi.Void> userdata,
  int transferred_bytes,
  int total_bytes,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<realm_error_t>)>(symbol: 'realm_dart_sync_wait_for_completion_callback')
external void realm_dart_sync_wait_for_completion_callback(
  ffi.Pointer<ffi.Void> userdata,
  ffi.Pointer<realm_error_t> error,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int32)>(symbol: 'realm_dart_user_change_callback')
external void realm_dart_user_change_callback(
  ffi.Pointer<ffi.Void> userdata,
  int state,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<realm_user_t>, ffi.Pointer<realm_app_error_t>)>(symbol: 'realm_dart_user_completion_callback')
external void realm_dart_user_completion_callback(
  ffi.Pointer<ffi.Void> userdata,
  ffi.Pointer<realm_user_t> user,
  ffi.Pointer<realm_app_error_t> error,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>(symbol: 'realm_dart_userdata_async_free')
external void realm_dart_userdata_async_free(
  ffi.Pointer<ffi.Void> userdata,
);

@ffi.Native<realm_dart_userdata_async_t Function(ffi.Handle, ffi.Pointer<ffi.Void>, ffi.Pointer<realm_scheduler_t>)>(symbol: 'realm_dart_userdata_async_new')
external realm_dart_userdata_async_t realm_dart_userdata_async_new(
  Object handle,
  ffi.Pointer<ffi.Void> callback,
  ffi.Pointer<realm_scheduler_t> scheduler,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<realm_app_error_t>)>(symbol: 'realm_dart_void_completion_callback')
external void realm_dart_void_completion_callback(
  ffi.Pointer<ffi.Void> userdata,
  ffi.Pointer<realm_app_error_t> error,
);

/// Deletes the following files for the given `realm_file_path` if they exist:
/// - the Realm file itself
/// - the .management folder
/// - the .note file
/// - the .log file
///
/// The .lock file for this Realm cannot and will not be deleted as this is unsafe.
/// If a different process / thread is accessing the Realm at the same time a corrupt state
/// could be the result and checking for a single process state is not possible here.
///
/// @param realm_file_path The path to the Realm file. All files will be derived from this.
/// @param[out] did_delete_realm If non-null, set to true if the primary Realm file was deleted.
/// Discard value if the function returns an error.
///
/// @return true if no error occurred.
///
/// @throws RLM_ERR_FILE_PERMISSION_DENIED if the operation was not permitted.
/// @throws RLM_ERR_FILE_ACCESS_ERROR for any other error while trying to delete the file or folder.
/// @throws RLM_ERR_DELETE_OPENED_REALM if the function was called on an open Realm.
@ffi.Native<ffi.Bool Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Bool>)>(symbol: 'realm_delete_files')
external bool realm_delete_files(
  ffi.Pointer<ffi.Char> realm_file_path,
  ffi.Pointer<ffi.Bool> did_delete_realm,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Handle)>(symbol: 'realm_detach_finalizer')
external void realm_detach_finalizer(
  ffi.Pointer<ffi.Void> finalizableHandle,
  Object handle,
);

/// Subscribe to notifications for this object.
///
/// @return A non-null pointer if no exception occurred.
@ffi.Native<
    ffi.Pointer<realm_notification_token_t> Function(ffi.Pointer<realm_dictionary_t>, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t,
        ffi.Pointer<realm_key_path_array_t>, realm_on_dictionary_change_func_t)>(symbol: 'realm_dictionary_add_notification_callback')
external ffi.Pointer<realm_notification_token_t> realm_dictionary_add_notification_callback(
  ffi.Pointer<realm_dictionary_t> arg0,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
  ffi.Pointer<realm_key_path_array_t> key_path_array,
  realm_on_dictionary_change_func_t on_change,
);

/// Clear a dictionary.
///
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_dictionary_t>)>(symbol: 'realm_dictionary_clear')
external bool realm_dictionary_clear(
  ffi.Pointer<realm_dictionary_t> arg0,
);

/// Check if the dictionary contains a certain key
///
/// @param key to search in the dictionary
/// @param found True if the such key exists
/// @return True if no exception occurred
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_dictionary_t>, realm_value_t, ffi.Pointer<ffi.Bool>)>(symbol: 'realm_dictionary_contains_key')
external bool realm_dictionary_contains_key(
  ffi.Pointer<realm_dictionary_t> arg0,
  realm_value_t key,
  ffi.Pointer<ffi.Bool> found,
);

/// Check if the dictionary contains a certain value
///
/// @param value to search in the dictionary
/// @param index the index of the value in the dictionry if such value exists
/// @return True if no exception occurred
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_dictionary_t>, realm_value_t, ffi.Pointer<ffi.Size>)>(symbol: 'realm_dictionary_contains_value')
external bool realm_dictionary_contains_value(
  ffi.Pointer<realm_dictionary_t> arg0,
  realm_value_t value,
  ffi.Pointer<ffi.Size> index,
);

/// Erase a dictionary element.
///
/// @param key The key of the element to erase.
/// @param out_erased If non-null, will be set to true if the element was found
/// and erased.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_dictionary_t>, realm_value_t, ffi.Pointer<ffi.Bool>)>(symbol: 'realm_dictionary_erase')
external bool realm_dictionary_erase(
  ffi.Pointer<realm_dictionary_t> arg0,
  realm_value_t key,
  ffi.Pointer<ffi.Bool> out_erased,
);

/// Find an element in a dictionary.
///
/// @param key The key to look for.
/// @param out_value If non-null, the value for the corresponding key.
/// @param out_found If non-null, will be set to true if the dictionary contained the key.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_dictionary_t>, realm_value_t, ffi.Pointer<realm_value_t>, ffi.Pointer<ffi.Bool>)>(
    symbol: 'realm_dictionary_find')
external bool realm_dictionary_find(
  ffi.Pointer<realm_dictionary_t> arg0,
  realm_value_t key,
  ffi.Pointer<realm_value_t> out_value,
  ffi.Pointer<ffi.Bool> out_found,
);

/// Get an dictionary from a thread-safe reference, potentially originating in a
/// different `realm_t` instance
@ffi.Native<ffi.Pointer<realm_dictionary_t> Function(ffi.Pointer<realm_t>, ffi.Pointer<realm_thread_safe_reference_t>)>(
    symbol: 'realm_dictionary_from_thread_safe_reference')
external ffi.Pointer<realm_dictionary_t> realm_dictionary_from_thread_safe_reference(
  ffi.Pointer<realm_t> arg0,
  ffi.Pointer<realm_thread_safe_reference_t> arg1,
);

/// Get the key-value pair at @a index.
///
/// Note that the indices of elements in the dictionary move around as other
/// elements are inserted/removed.
///
/// @param index The index in the dictionary.
/// @param out_key If non-null, will be set to the key at the corresponding index.
/// @param out_value If non-null, will be set to the value at the corresponding index.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_dictionary_t>, ffi.Size, ffi.Pointer<realm_value_t>, ffi.Pointer<realm_value_t>)>(
    symbol: 'realm_dictionary_get')
external bool realm_dictionary_get(
  ffi.Pointer<realm_dictionary_t> arg0,
  int index,
  ffi.Pointer<realm_value_t> out_key,
  ffi.Pointer<realm_value_t> out_value,
);

/// Returns the list of keys changed for the dictionary passed as argument.
/// The user must assure that there is enough memory to accomodate all the keys
/// calling `realm_dictionary_get_changes` before.
///
/// @param changes valid ptr to the dictionary changes structure
/// @param deletions list of deleted keys
/// @param deletions_size size of the list of deleted keys
/// @param insertions list of inserted keys
/// @param insertions_size size of the list of inserted keys
/// @param modifications list of modified keys
/// @param modification_size size of the list of modified keys
@ffi.Native<
    ffi.Void Function(ffi.Pointer<realm_dictionary_changes_t>, ffi.Pointer<realm_value_t>, ffi.Pointer<ffi.Size>, ffi.Pointer<realm_value_t>,
        ffi.Pointer<ffi.Size>, ffi.Pointer<realm_value_t>, ffi.Pointer<ffi.Size>)>(symbol: 'realm_dictionary_get_changed_keys')
external void realm_dictionary_get_changed_keys(
  ffi.Pointer<realm_dictionary_changes_t> changes,
  ffi.Pointer<realm_value_t> deletions,
  ffi.Pointer<ffi.Size> deletions_size,
  ffi.Pointer<realm_value_t> insertions,
  ffi.Pointer<ffi.Size> insertions_size,
  ffi.Pointer<realm_value_t> modifications,
  ffi.Pointer<ffi.Size> modification_size,
);

/// Returns the number of changes occurred to the dictionary passed as argument
///
/// @param changes valid ptr to the dictionary changes structure
/// @param out_deletions_size number of deletions
/// @param out_insertion_size number of insertions
/// @param out_modification_size number of modifications
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_dictionary_changes_t>, ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Size>)>(
    symbol: 'realm_dictionary_get_changes')
external void realm_dictionary_get_changes(
  ffi.Pointer<realm_dictionary_changes_t> changes,
  ffi.Pointer<ffi.Size> out_deletions_size,
  ffi.Pointer<ffi.Size> out_insertion_size,
  ffi.Pointer<ffi.Size> out_modification_size,
);

/// Return the list of keys stored in the dictionary
///
/// @param out_size number of keys
/// @param out_keys the list of keys in the dictionary, the memory has to be released once it is no longer used.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_dictionary_t>, ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Pointer<realm_results_t>>)>(
    symbol: 'realm_dictionary_get_keys')
external bool realm_dictionary_get_keys(
  ffi.Pointer<realm_dictionary_t> arg0,
  ffi.Pointer<ffi.Size> out_size,
  ffi.Pointer<ffi.Pointer<realm_results_t>> out_keys,
);

/// Get object identified by key
///
/// @return A non-NULL pointer if the value associated with key is an object.
@ffi.Native<ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_dictionary_t>, realm_value_t)>(symbol: 'realm_dictionary_get_linked_object')
external ffi.Pointer<realm_object_t> realm_dictionary_get_linked_object(
  ffi.Pointer<realm_dictionary_t> arg0,
  realm_value_t key,
);

/// Get the property that this dictionary came from.
///
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_dictionary_t>, ffi.Pointer<realm_property_info_t>)>(symbol: 'realm_dictionary_get_property')
external bool realm_dictionary_get_property(
  ffi.Pointer<realm_dictionary_t> arg0,
  ffi.Pointer<realm_property_info_t> out_info,
);

/// Insert or update an element in a dictionary.
///
/// If the key already exists, the value will be overwritten.
///
/// @param key The lookup key.
/// @param value The value to insert.
/// @param out_index If non-null, will be set to the index of the element after
/// insertion/update.
/// @param out_inserted If non-null, will be set to true if the key did not
/// already exist.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_dictionary_t>, realm_value_t, realm_value_t, ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Bool>)>(
    symbol: 'realm_dictionary_insert')
external bool realm_dictionary_insert(
  ffi.Pointer<realm_dictionary_t> arg0,
  realm_value_t key,
  realm_value_t value,
  ffi.Pointer<ffi.Size> out_index,
  ffi.Pointer<ffi.Bool> out_inserted,
);

/// Insert an embedded object.
///
/// @return A non-NULL pointer if the object was created successfully.
@ffi.Native<ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_dictionary_t>, realm_value_t)>(symbol: 'realm_dictionary_insert_embedded')
external ffi.Pointer<realm_object_t> realm_dictionary_insert_embedded(
  ffi.Pointer<realm_dictionary_t> arg0,
  realm_value_t key,
);

/// Check if a list is valid.
///
/// @return True if the list is valid.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_dictionary_t>)>(symbol: 'realm_dictionary_is_valid')
external bool realm_dictionary_is_valid(
  ffi.Pointer<realm_dictionary_t> arg0,
);

/// Resolve the list in the context of a given Realm instance.
///
/// This is equivalent to producing a thread-safe reference and resolving it in the frozen realm.
///
/// If resolution is possible, a valid resolved object is produced at '*resolved*'.
/// If resolution is not possible, but no error occurs, '*resolved' is set to NULL
///
/// @return true if no error occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_dictionary_t>, ffi.Pointer<realm_t>, ffi.Pointer<ffi.Pointer<realm_dictionary_t>>)>(
    symbol: 'realm_dictionary_resolve_in')
external bool realm_dictionary_resolve_in(
  ffi.Pointer<realm_dictionary_t> list,
  ffi.Pointer<realm_t> target_realm,
  ffi.Pointer<ffi.Pointer<realm_dictionary_t>> resolved,
);

/// Get the size of a dictionary (the number of unique keys).
///
/// This function may fail if the object owning the dictionary has been deleted.
///
/// @param out_size Where to put the dictionary size. May be NULL.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_dictionary_t>, ffi.Pointer<ffi.Size>)>(symbol: 'realm_dictionary_size')
external bool realm_dictionary_size(
  ffi.Pointer<realm_dictionary_t> arg0,
  ffi.Pointer<ffi.Size> out_size,
);

/// Convert a dictionary to results.
///
/// @return A non-null pointer if no exception occurred.
@ffi.Native<ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_dictionary_t>)>(symbol: 'realm_dictionary_to_results')
external ffi.Pointer<realm_results_t> realm_dictionary_to_results(
  ffi.Pointer<realm_dictionary_t> arg0,
);

/// Return true if two API objects refer to the same underlying data. Objects
/// with different types are never equal.
///
/// Note: This function cannot be used with types that have value semantics, only
/// opaque types that have object semantics.
///
/// - `realm_t` objects are identical if they represent the same instance (not
/// just if they represent the same file).
/// - `realm_schema_t` objects are equal if the represented schemas are equal.
/// - `realm_config_t` objects are equal if the configurations are equal.
/// - `realm_object_t` objects are identical if they belong to the same realm
/// and class, and have the same object key.
/// - `realm_list_t` and other collection objects are identical if they come
/// from the same object and property.
/// - `realm_query_t` objects are never equal.
/// - `realm_scheduler_t` objects are equal if they represent the same
/// scheduler.
/// - Query descriptor objects are equal if they represent equivalent
/// descriptors.
/// - `realm_async_error_t` objects are equal if they represent the same
/// exception instance.
///
/// This function cannot fail.
@ffi.Native<ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>(symbol: 'realm_equals')
external bool realm_equals(
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<ffi.Void> arg1,
);

/// Find a by the name of @a name.
///
/// @param name The name of the class.
/// @param out_found Set to true if the class was found and no error occurred.
/// Otherwise, false. May not be NULL.
/// @param out_class_info A pointer to a `realm_class_info_t` that will be
/// populated with information about the class. May be
/// NULL.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Bool>, ffi.Pointer<realm_class_info_t>)>(symbol: 'realm_find_class')
external bool realm_find_class(
  ffi.Pointer<realm_t> arg0,
  ffi.Pointer<ffi.Char> name,
  ffi.Pointer<ffi.Bool> out_found,
  ffi.Pointer<realm_class_info_t> out_class_info,
);

/// Find the primary key property for a class, if it has one.
///
/// @param class_key The table key for this class.
/// @param out_found Will be set to true if the property was found. May not be
/// NULL.
/// @param out_property_info A property to a `realm_property_info_t` that will be
/// populated with information about the property, if it
/// was found. May be NULL.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>, realm_class_key_t, ffi.Pointer<ffi.Bool>, ffi.Pointer<realm_property_info_t>)>(
    symbol: 'realm_find_primary_key_property')
external bool realm_find_primary_key_property(
  ffi.Pointer<realm_t> arg0,
  int class_key,
  ffi.Pointer<ffi.Bool> out_found,
  ffi.Pointer<realm_property_info_t> out_property_info,
);

/// Find a property by the internal (non-public) name of @a name.
///
/// @param class_key The table key for the class.
/// @param name The name of the property.
/// @param out_found Will be set to true if the property was found. May not be
/// NULL.
/// @param out_property_info A pointer to a `realm_property_info_t` that will be
/// populated with information about the property. May
/// be NULL.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>, realm_class_key_t, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Bool>, ffi.Pointer<realm_property_info_t>)>(
    symbol: 'realm_find_property')
external bool realm_find_property(
  ffi.Pointer<realm_t> arg0,
  int class_key,
  ffi.Pointer<ffi.Char> name,
  ffi.Pointer<ffi.Bool> out_found,
  ffi.Pointer<realm_property_info_t> out_property_info,
);

/// Find a property with the public name of @a name.
///
/// @param class_key The table key for the class.
/// @param public_name The public name of the property.
/// @param out_found Will be set to true if the property was found. May not be
/// NULL.
/// @param out_property_info A pointer to a `realm_property_info_t` that will be
/// populated with information about the property. May
/// be NULL.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>, realm_class_key_t, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Bool>, ffi.Pointer<realm_property_info_t>)>(
    symbol: 'realm_find_property_by_public_name')
external bool realm_find_property_by_public_name(
  ffi.Pointer<realm_t> arg0,
  int class_key,
  ffi.Pointer<ffi.Char> public_name,
  ffi.Pointer<ffi.Bool> out_found,
  ffi.Pointer<realm_property_info_t> out_property_info,
);

@ffi.Native<ffi.Pointer<realm_sync_config_t> Function(ffi.Pointer<realm_user_t>)>(symbol: 'realm_flx_sync_config_new')
external ffi.Pointer<realm_sync_config_t> realm_flx_sync_config_new(
  ffi.Pointer<realm_user_t> arg0,
);

/// Free memory allocated by the module this library was linked into.
///
/// This is needed for raw memory buffers such as string copies or arrays
/// returned from a library function. Realm C Wrapper objects on the other hand
/// should always be freed with realm_release() only.
@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>(symbol: 'realm_free')
external void realm_free(
  ffi.Pointer<ffi.Void> buffer,
);

/// Produce a frozen view of this realm.
///
/// @return A non-NULL realm instance representing the frozen state.
@ffi.Native<ffi.Pointer<realm_t> Function(ffi.Pointer<realm_t>)>(symbol: 'realm_freeze')
external ffi.Pointer<realm_t> realm_freeze(
  ffi.Pointer<realm_t> arg0,
);

/// Create a `realm_t` object from a thread-safe reference to the same realm.
///
/// @param tsr Thread-safe reference object created by calling
/// `realm_get_thread_safe_reference()` with a `realm_t` instance.
/// @param scheduler The scheduler to use for the new `realm_t` instance. May be
/// NULL, in which case the default scheduler for the current
/// thread is used.
/// @return A non-null pointer if no error occurred.
@ffi.Native<ffi.Pointer<realm_t> Function(ffi.Pointer<realm_thread_safe_reference_t>, ffi.Pointer<realm_scheduler_t>)>(
    symbol: 'realm_from_thread_safe_reference')
external ffi.Pointer<realm_t> realm_from_thread_safe_reference(
  ffi.Pointer<realm_thread_safe_reference_t> tsr,
  ffi.Pointer<realm_scheduler_t> scheduler,
);

/// Get information about an async error, potentially coming from another thread.
///
/// This function does not allocate any memory.
///
/// @param err A pointer to a `realm_error_t` struct that will be populated with
/// information about the error. May not be NULL.
/// @return A bool indicating whether or not an error is available to be returned
/// @see realm_get_last_error()
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_async_error_t>, ffi.Pointer<realm_error_t>)>(symbol: 'realm_get_async_error')
external bool realm_get_async_error(
  ffi.Pointer<realm_async_error_t> err,
  ffi.Pointer<realm_error_t> out_err,
);

/// Fetch the backlinks for the object passed as argument.
/// @return a valid ptr to realm results that contains all the backlinks for the object, or null in case of errors.
@ffi.Native<ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_object_t>, realm_class_key_t, realm_property_key_t)>(symbol: 'realm_get_backlinks')
external ffi.Pointer<realm_results_t> realm_get_backlinks(
  ffi.Pointer<realm_object_t> object,
  int source_table_key,
  int property_key,
);

/// Get the class with @a key from the schema.
///
/// Passing an invalid @a key for this schema is considered an error.
///
/// @param key The key of the class, as discovered by `realm_get_class_keys()`.
/// @param out_class_info A pointer to a `realm_class_info_t` that will be
/// populated with the information of the class. May be
/// NULL, though that's kind of pointless.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>, realm_class_key_t, ffi.Pointer<realm_class_info_t>)>(symbol: 'realm_get_class')
external bool realm_get_class(
  ffi.Pointer<realm_t> arg0,
  int key,
  ffi.Pointer<realm_class_info_t> out_class_info,
);

/// Get the table keys for classes in the schema.
/// In case of errors this function will return false (errors to be fetched via `realm_get_last_error()`).
/// If data is not copied the function will return true and set  `out_n` with the capacity needed.
/// Data is only copied if the input array has enough capacity, otherwise the needed  array capacity will be set.
///
/// @param out_keys An array that will contain the keys of each class in the
/// schema. Array may be NULL, in this case no data will be copied and `out_n` set if not NULL.
/// @param max The maximum number of keys to write to `out_keys`.
/// @param out_n The actual number of classes. May be NULL.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>, ffi.Pointer<realm_class_key_t>, ffi.Size, ffi.Pointer<ffi.Size>)>(symbol: 'realm_get_class_keys')
external bool realm_get_class_keys(
  ffi.Pointer<realm_t> arg0,
  ffi.Pointer<realm_class_key_t> out_keys,
  int max,
  ffi.Pointer<ffi.Size> out_n,
);

/// Get the list of properties for the class with this @a key.
/// In case of errors this function will return false (errors to be fetched via `realm_get_last_error()`).
/// If data is not copied the function will return true and set  `out_n` with the capacity needed.
/// Data is only copied if the input array has enough capacity, otherwise the needed  array capacity will be set.
///
/// @param out_properties  A pointer to an array of `realm_property_info_t`, which
/// will be populated with the information about the
/// properties.  Array may be NULL, in this case no data will be copied and `out_n` set if not
/// NULL.
/// @param max The maximum number of entries to write to `out_properties`.
/// @param out_n The actual number of properties written to `out_properties`.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>, realm_class_key_t, ffi.Pointer<realm_property_info_t>, ffi.Size, ffi.Pointer<ffi.Size>)>(
    symbol: 'realm_get_class_properties')
external bool realm_get_class_properties(
  ffi.Pointer<realm_t> arg0,
  int key,
  ffi.Pointer<realm_property_info_t> out_properties,
  int max,
  ffi.Pointer<ffi.Size> out_n,
);

/// Get a dictionary instance for the property of an object.
///
/// Note: It is up to the caller to call `realm_release()` on the returned dictionary.
///
/// @return A non-null pointer if no exception occurred.
@ffi.Native<ffi.Pointer<realm_dictionary_t> Function(ffi.Pointer<realm_object_t>, realm_property_key_t)>(symbol: 'realm_get_dictionary')
external ffi.Pointer<realm_dictionary_t> realm_get_dictionary(
  ffi.Pointer<realm_object_t> arg0,
  int arg1,
);

/// Get the last error that happened on this thread.
///
/// Errors are thread-local. Getting the error must happen on the same thread as
/// the call that caused the error to occur. The error is specific to the current
/// thread, and not the Realm instance for which the error occurred.
///
/// Note: The error message in @a err will only be safe to use until the next API
/// call is made on the current thread.
///
/// Note: The error is not cleared by subsequent successful calls to this
/// function, but it will be overwritten by subsequent failing calls to
/// other library functions.
///
/// Note: Calling this function does not clear the current last error.
///
/// This function does not allocate any memory.
///
/// @param err A pointer to a `realm_error_t` struct that will be populated with
/// information about the last error, if there is one. May be NULL.
/// @return True if an error occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_error_t>)>(symbol: 'realm_get_last_error')
external bool realm_get_last_error(
  ffi.Pointer<realm_error_t> err,
);

/// Convert the last error to `realm_async_error_t`, which can safely be passed
/// between threads.
///
/// Note: This function does not clear the last error.
///
/// @return A non-null pointer if there was an error on this thread.
/// @see realm_get_last_error()
/// @see realm_get_async_error()
/// @see realm_clear_last_error()
@ffi.Native<ffi.Pointer<realm_async_error_t> Function()>(symbol: 'realm_get_last_error_as_async_error')
external ffi.Pointer<realm_async_error_t> realm_get_last_error_as_async_error();

@ffi.Native<ffi.Pointer<ffi.Char> Function()>(symbol: 'realm_get_library_cpu_arch')
external ffi.Pointer<ffi.Char> realm_get_library_cpu_arch();

/// Get a string representing the version number of the Realm library.
///
/// @return A null-terminated string.
@ffi.Native<ffi.Pointer<ffi.Char> Function()>(symbol: 'realm_get_library_version')
external ffi.Pointer<ffi.Char> realm_get_library_version();

/// Get individual components of the version number of the Realm library.
///
/// @param out_major The major version number (X.0.0).
/// @param out_minor The minor version number (0.X.0).
/// @param out_patch The patch version number (0.0.X).
/// @param out_extra The extra version string (0.0.0-X).
@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>(
    symbol: 'realm_get_library_version_numbers')
external void realm_get_library_version_numbers(
  ffi.Pointer<ffi.Int> out_major,
  ffi.Pointer<ffi.Int> out_minor,
  ffi.Pointer<ffi.Int> out_patch,
  ffi.Pointer<ffi.Pointer<ffi.Char>> out_extra,
);

/// Return the object linked by the given property
///
/// @return A non-NULL pointer if an object is found.
@ffi.Native<ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_object_t>, realm_property_key_t)>(symbol: 'realm_get_linked_object')
external ffi.Pointer<realm_object_t> realm_get_linked_object(
  ffi.Pointer<realm_object_t> arg0,
  int arg1,
);

/// Get a list instance for the property of an object.
///
/// Note: It is up to the caller to call `realm_release()` on the returned list.
///
/// @return A non-null pointer if no exception occurred.
@ffi.Native<ffi.Pointer<realm_list_t> Function(ffi.Pointer<realm_object_t>, realm_property_key_t)>(symbol: 'realm_get_list')
external ffi.Pointer<realm_list_t> realm_get_list(
  ffi.Pointer<realm_object_t> arg0,
  int arg1,
);

/// Return the number of classes in the Realm's schema.
///
/// This cannot fail.
@ffi.Native<ffi.Size Function(ffi.Pointer<realm_t>)>(symbol: 'realm_get_num_classes')
external int realm_get_num_classes(
  ffi.Pointer<realm_t> arg0,
);

/// Get the number of objects in a table (class).
///
/// @param out_count A pointer to a `size_t` that will contain the number of
/// objects, if successful.
/// @return True if the table key was valid for this realm.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>, realm_class_key_t, ffi.Pointer<ffi.Size>)>(symbol: 'realm_get_num_objects')
external bool realm_get_num_objects(
  ffi.Pointer<realm_t> arg0,
  int arg1,
  ffi.Pointer<ffi.Size> out_count,
);

/// Get the number of versions found in the Realm file.
///
/// @param out_versions_count A pointer to a `size_t` that will contain the number of
/// versions, if successful.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>, ffi.Pointer<ffi.Uint64>)>(symbol: 'realm_get_num_versions')
external bool realm_get_num_versions(
  ffi.Pointer<realm_t> arg0,
  ffi.Pointer<ffi.Uint64> out_versions_count,
);

/// Get an object with a particular object key.
///
/// @param class_key The class key.
/// @param obj_key The key to the object. Passing a non-existent key is
/// considered an error.
/// @return A non-NULL pointer if no exception occurred.
@ffi.Native<ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_t>, realm_class_key_t, realm_object_key_t)>(symbol: 'realm_get_object')
external ffi.Pointer<realm_object_t> realm_get_object(
  ffi.Pointer<realm_t> arg0,
  int class_key,
  int obj_key,
);

/// Find a property by its column key.
///
/// It is an error to pass a property @a key that is not present in this class.
///
/// @param class_key The key of the class.
/// @param key The column key for the property.
/// @param out_property_info A pointer to a `realm_property_info_t` that will be
/// populated with information about the property.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>, realm_class_key_t, realm_property_key_t, ffi.Pointer<realm_property_info_t>)>(symbol: 'realm_get_property')
external bool realm_get_property(
  ffi.Pointer<realm_t> arg0,
  int class_key,
  int key,
  ffi.Pointer<realm_property_info_t> out_property_info,
);

/// Get the property keys for the class with this @a key.
/// In case of errors this function will return false (errors to be fetched via `realm_get_last_error()`).
/// If data is not copied the function will return true and set  `out_n` with the capacity needed.
/// Data is only copied if the input array has enough capacity, otherwise the needed  array capacity will be set.
///
/// @param key The class key.
/// @param out_col_keys An array of property keys. Array may be NULL,
/// in this case no data will be copied and `out_n` set if not NULL.
/// @param max The maximum number of keys to write to `out_col_keys`. Ignored if
/// `out_col_keys == NULL`.
/// @param out_n The actual number of properties written to `out_col_keys` (if
/// non-NULL), or number of properties in the class.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>, realm_class_key_t, ffi.Pointer<realm_property_key_t>, ffi.Size, ffi.Pointer<ffi.Size>)>(
    symbol: 'realm_get_property_keys')
external bool realm_get_property_keys(
  ffi.Pointer<realm_t> arg0,
  int key,
  ffi.Pointer<realm_property_key_t> out_col_keys,
  int max,
  ffi.Pointer<ffi.Size> out_n,
);

/// Get the schema for this realm.
///
/// Note: The returned value is allocated by this function, so `realm_release()`
/// must be called on it.
@ffi.Native<ffi.Pointer<realm_schema_t> Function(ffi.Pointer<realm_t>)>(symbol: 'realm_get_schema')
external ffi.Pointer<realm_schema_t> realm_get_schema(
  ffi.Pointer<realm_t> arg0,
);

/// Get the schema version for this realm.
///
/// This function cannot fail.
@ffi.Native<ffi.Uint64 Function(ffi.Pointer<realm_t>)>(symbol: 'realm_get_schema_version')
external int realm_get_schema_version(
  ffi.Pointer<realm_t> realm,
);

/// Get a set instance for the property of an object.
///
/// Note: It is up to the caller to call `realm_release()` on the returned set.
///
/// @return A non-null pointer if no exception occurred.
@ffi.Native<ffi.Pointer<realm_set_t> Function(ffi.Pointer<realm_object_t>, realm_property_key_t)>(symbol: 'realm_get_set')
external ffi.Pointer<realm_set_t> realm_get_set(
  ffi.Pointer<realm_object_t> arg0,
  int arg1,
);

/// Get the value for a property.
///
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_object_t>, realm_property_key_t, ffi.Pointer<realm_value_t>)>(symbol: 'realm_get_value')
external bool realm_get_value(
  ffi.Pointer<realm_object_t> arg0,
  int arg1,
  ffi.Pointer<realm_value_t> out_value,
);

/// Get the value for the property at the specified index in the object's schema.
/// @param prop_index The index of the property in the class properties array the realm was opened with.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_object_t>, ffi.Size, ffi.Pointer<realm_value_t>)>(symbol: 'realm_get_value_by_property_index')
external bool realm_get_value_by_property_index(
  ffi.Pointer<realm_object_t> object,
  int prop_index,
  ffi.Pointer<realm_value_t> out_value,
);

/// Get the values for several properties.
///
/// This is provided as an alternative to calling `realm_get_value()` multiple
/// times in a row, which is particularly useful for language runtimes where
/// crossing the native bridge is comparatively expensive. In addition, it
/// eliminates some parameter validation that would otherwise be repeated for
/// each call.
///
/// Example use cases:
///
/// - Extracting all properties of an object for serialization.
/// - Converting an object to some in-memory representation.
///
/// @param num_values The number of elements in @a properties and @a out_values.
/// @param properties The keys for the properties to fetch. May not be NULL.
/// @param out_values Where to write the property values. If an error occurs,
/// this array may only be partially initialized. May not be
/// NULL.
/// @return True if no exception occurs.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_object_t>, ffi.Size, ffi.Pointer<realm_property_key_t>, ffi.Pointer<realm_value_t>)>(symbol: 'realm_get_values')
external bool realm_get_values(
  ffi.Pointer<realm_object_t> arg0,
  int num_values,
  ffi.Pointer<realm_property_key_t> properties,
  ffi.Pointer<realm_value_t> out_values,
);

/// Get the VersionID of the current transaction.
///
/// @param out_found True if version information is available. This requires an available Read or Write transaction.
/// @param out_version The version of the current transaction. If `out_found` returns False, this returns (0,0).
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>, ffi.Pointer<ffi.Bool>, ffi.Pointer<realm_version_id_t>)>(symbol: 'realm_get_version_id')
external bool realm_get_version_id(
  ffi.Pointer<realm_t> arg0,
  ffi.Pointer<ffi.Bool> out_found,
  ffi.Pointer<realm_version_id_t> out_version,
);

/// Complete a HTTP request with the given response.
///
/// @param request_context Internal state pointer passed by Core when invoking realm_http_request_func_t
/// to start the request.
/// @param response The server response to the HTTP request initiated by Core.
@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<realm_http_response_t>)>(symbol: 'realm_http_transport_complete_request')
external void realm_http_transport_complete_request(
  ffi.Pointer<ffi.Void> request_context,
  ffi.Pointer<realm_http_response_t> response,
);

/// Create a new HTTP transport with these callbacks implementing its functionality.
@ffi.Native<ffi.Pointer<realm_http_transport_t> Function(realm_http_request_func_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(
    symbol: 'realm_http_transport_new')
external ffi.Pointer<realm_http_transport_t> realm_http_transport_new(
  realm_http_request_func_t arg0,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// True if the Realm file is closed.
///
/// This function cannot fail.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>)>(symbol: 'realm_is_closed')
external bool realm_is_closed(
  ffi.Pointer<realm_t> arg0,
);

/// True if a Realm C Wrapper object is "frozen" (immutable).
///
/// Objects, collections, and results can be frozen. For all other types, this
/// function always returns false.
@ffi.Native<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(symbol: 'realm_is_frozen')
external bool realm_is_frozen(
  ffi.Pointer<ffi.Void> arg0,
);

/// Return true if the realm is in a write transaction.
///
/// This function cannot fail.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>)>(symbol: 'realm_is_writable')
external bool realm_is_writable(
  ffi.Pointer<realm_t> arg0,
);

/// Subscribe to notifications for this object.
///
/// @return A non-null pointer if no exception occurred.
@ffi.Native<
    ffi.Pointer<realm_notification_token_t> Function(ffi.Pointer<realm_list_t>, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t,
        ffi.Pointer<realm_key_path_array_t>, realm_on_collection_change_func_t)>(symbol: 'realm_list_add_notification_callback')
external ffi.Pointer<realm_notification_token_t> realm_list_add_notification_callback(
  ffi.Pointer<realm_list_t> arg0,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
  ffi.Pointer<realm_key_path_array_t> key_path_array,
  realm_on_collection_change_func_t on_change,
);

/// Clear a list, removing all elements in the list. In a list of links, this
/// does *NOT* delete the target objects.
///
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_list_t>)>(symbol: 'realm_list_clear')
external bool realm_list_clear(
  ffi.Pointer<realm_list_t> arg0,
);

/// Erase the element at @a index.
///
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_list_t>, ffi.Size)>(symbol: 'realm_list_erase')
external bool realm_list_erase(
  ffi.Pointer<realm_list_t> arg0,
  int index,
);

/// Find the value in the list passed as parameter.
/// @param value to search in the list
/// @param out_index the index in the list where the value has been found or realm::not_found.
/// @param out_found boolean that indicates whether the value is found or not
/// @return true if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_list_t>, ffi.Pointer<realm_value_t>, ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Bool>)>(symbol: 'realm_list_find')
external bool realm_list_find(
  ffi.Pointer<realm_list_t> arg0,
  ffi.Pointer<realm_value_t> value,
  ffi.Pointer<ffi.Size> out_index,
  ffi.Pointer<ffi.Bool> out_found,
);

/// Get an list from a thread-safe reference, potentially originating in a
/// different `realm_t` instance
@ffi.Native<ffi.Pointer<realm_list_t> Function(ffi.Pointer<realm_t>, ffi.Pointer<realm_thread_safe_reference_t>)>(
    symbol: 'realm_list_from_thread_safe_reference')
external ffi.Pointer<realm_list_t> realm_list_from_thread_safe_reference(
  ffi.Pointer<realm_t> arg0,
  ffi.Pointer<realm_thread_safe_reference_t> arg1,
);

/// Get the value at @a index.
///
/// @param out_value The resulting value, if no error occurred. May be NULL,
/// though nonsensical.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_list_t>, ffi.Size, ffi.Pointer<realm_value_t>)>(symbol: 'realm_list_get')
external bool realm_list_get(
  ffi.Pointer<realm_list_t> arg0,
  int index,
  ffi.Pointer<realm_value_t> out_value,
);

/// Get object identified at index
///
/// @return A non-NULL pointer if value is an object.
@ffi.Native<ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_list_t>, ffi.Size)>(symbol: 'realm_list_get_linked_object')
external ffi.Pointer<realm_object_t> realm_list_get_linked_object(
  ffi.Pointer<realm_list_t> arg0,
  int index,
);

/// Get the property that this list came from.
///
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_list_t>, ffi.Pointer<realm_property_info_t>)>(symbol: 'realm_list_get_property')
external bool realm_list_get_property(
  ffi.Pointer<realm_list_t> arg0,
  ffi.Pointer<realm_property_info_t> out_property_info,
);

/// Insert @a value at @a index.
///
/// @param value The value to insert.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_list_t>, ffi.Size, realm_value_t)>(symbol: 'realm_list_insert')
external bool realm_list_insert(
  ffi.Pointer<realm_list_t> arg0,
  int index,
  realm_value_t value,
);

/// Insert an embedded object at a given position.
///
/// @return A non-NULL pointer if the object was created successfully.
@ffi.Native<ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_list_t>, ffi.Size)>(symbol: 'realm_list_insert_embedded')
external ffi.Pointer<realm_object_t> realm_list_insert_embedded(
  ffi.Pointer<realm_list_t> arg0,
  int index,
);

/// Check if a list is valid.
///
/// @return True if the list is valid.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_list_t>)>(symbol: 'realm_list_is_valid')
external bool realm_list_is_valid(
  ffi.Pointer<realm_list_t> arg0,
);

/// Move the element at @a from_index to @a to_index.
///
/// @param from_index The index of the element to move.
/// @param to_index The index to move the element to.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_list_t>, ffi.Size, ffi.Size)>(symbol: 'realm_list_move')
external bool realm_list_move(
  ffi.Pointer<realm_list_t> arg0,
  int from_index,
  int to_index,
);

/// In a list of objects, delete all objects in the list and clear the list. In a
/// list of values, clear the list.
///
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_list_t>)>(symbol: 'realm_list_remove_all')
external bool realm_list_remove_all(
  ffi.Pointer<realm_list_t> arg0,
);

/// Resolve the list in the context of a given Realm instance.
///
/// This is equivalent to producing a thread-safe reference and resolving it in the frozen realm.
///
/// If resolution is possible, a valid resolved object is produced at '*resolved*'.
/// If resolution is not possible, but no error occurs, '*resolved' is set to NULL
///
/// @return true if no error occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_list_t>, ffi.Pointer<realm_t>, ffi.Pointer<ffi.Pointer<realm_list_t>>)>(symbol: 'realm_list_resolve_in')
external bool realm_list_resolve_in(
  ffi.Pointer<realm_list_t> list,
  ffi.Pointer<realm_t> target_realm,
  ffi.Pointer<ffi.Pointer<realm_list_t>> resolved,
);

/// Set the value at @a index.
///
/// @param value The value to set.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_list_t>, ffi.Size, realm_value_t)>(symbol: 'realm_list_set')
external bool realm_list_set(
  ffi.Pointer<realm_list_t> arg0,
  int index,
  realm_value_t value,
);

/// Create an embedded object at a given position.
///
/// @return A non-NULL pointer if the object was created successfully.
@ffi.Native<ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_list_t>, ffi.Size)>(symbol: 'realm_list_set_embedded')
external ffi.Pointer<realm_object_t> realm_list_set_embedded(
  ffi.Pointer<realm_list_t> arg0,
  int index,
);

/// Get the size of a list, in number of elements.
///
/// This function may fail if the object owning the list has been deleted.
///
/// @param out_size Where to put the list size. May be NULL.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_list_t>, ffi.Pointer<ffi.Size>)>(symbol: 'realm_list_size')
external bool realm_list_size(
  ffi.Pointer<realm_list_t> arg0,
  ffi.Pointer<ffi.Size> out_size,
);

/// Convert a list to results.
///
/// @return A non-null pointer if no exception occurred.
@ffi.Native<ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_list_t>)>(symbol: 'realm_list_to_results')
external ffi.Pointer<realm_results_t> realm_list_to_results(
  ffi.Pointer<realm_list_t> arg0,
);

/// Implement aggregate for mongodb collection
/// @param collection ptr to the collection to fetch from
/// @param filter_ejson extended json string serialization representing the filter to apply to this operation
/// @param data user data to pass down to this function
/// @param delete_data deleter for user data
/// @param callback to invoke with the result
/// @return True if completes successfully, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_mongodb_collection_t>, realm_string_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t,
        realm_mongodb_callback_t)>(symbol: 'realm_mongo_collection_aggregate')
external bool realm_mongo_collection_aggregate(
  ffi.Pointer<realm_mongodb_collection_t> collection,
  realm_string_t filter_ejson,
  ffi.Pointer<ffi.Void> data,
  realm_free_userdata_func_t delete_data,
  realm_mongodb_callback_t callback,
);

/// Implement count for mongodb collection
/// @param collection ptr to the collection to fetch from
/// @param filter_ejson extended json string serialization representing the filter to apply to this operation
/// @param limit number of collectio
/// @param data user data to pass down to this function
/// @param delete_data deleter for user data
/// @param callback to invoke with the result
/// @return True if completes successfully, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_mongodb_collection_t>, realm_string_t, ffi.Int64, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t,
        realm_mongodb_callback_t)>(symbol: 'realm_mongo_collection_count')
external bool realm_mongo_collection_count(
  ffi.Pointer<realm_mongodb_collection_t> collection,
  realm_string_t filter_ejson,
  int limit,
  ffi.Pointer<ffi.Void> data,
  realm_free_userdata_func_t delete_data,
  realm_mongodb_callback_t callback,
);

/// Implement delete_many for mongodb collection
/// @param collection name of the collection to fetch from
/// @param filter_ejson extended json string serialization representing the filter to apply to this operation
/// @param data user data to pass down to this function
/// @param delete_data deleter for user data
/// @param callback to invoke with the result
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_mongodb_collection_t>, realm_string_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t,
        realm_mongodb_callback_t)>(symbol: 'realm_mongo_collection_delete_many')
external bool realm_mongo_collection_delete_many(
  ffi.Pointer<realm_mongodb_collection_t> collection,
  realm_string_t filter_ejson,
  ffi.Pointer<ffi.Void> data,
  realm_free_userdata_func_t delete_data,
  realm_mongodb_callback_t callback,
);

/// Implement delete_one for mongodb collection
/// @param collection name of the collection to fetch from
/// @param filter_ejson extended json string serialization representing the filter to apply to this operation
/// @param data user data to pass down to this function
/// @param delete_data deleter for user data
/// @param callback to invoke with the result
/// @return True if completes successfully, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_mongodb_collection_t>, realm_string_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t,
        realm_mongodb_callback_t)>(symbol: 'realm_mongo_collection_delete_one')
external bool realm_mongo_collection_delete_one(
  ffi.Pointer<realm_mongodb_collection_t> collection,
  realm_string_t filter_ejson,
  ffi.Pointer<ffi.Void> data,
  realm_free_userdata_func_t delete_data,
  realm_mongodb_callback_t callback,
);

/// Implement find for mongodb collection
/// @param collection ptr to the collection to fetch from
/// @param filter_ejson extended json string serialization representing the filter to apply to this operation
/// @param options set of possible options to apply to this operation
/// @param data user data to pass down to this function
/// @param delete_data deleter for user data
/// @param callback to invoke with the result
/// @return True if completes successfully, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_mongodb_collection_t>, realm_string_t, ffi.Pointer<realm_mongodb_find_options_t>, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t, realm_mongodb_callback_t)>(symbol: 'realm_mongo_collection_find')
external bool realm_mongo_collection_find(
  ffi.Pointer<realm_mongodb_collection_t> collection,
  realm_string_t filter_ejson,
  ffi.Pointer<realm_mongodb_find_options_t> options,
  ffi.Pointer<ffi.Void> data,
  realm_free_userdata_func_t delete_data,
  realm_mongodb_callback_t callback,
);

/// Implement find_one for mongodb collection
/// @param collection ptr to the collection to fetch from
/// @param filter_ejson extended json string serialization representing the filter to apply to this operation
/// @param options set of possible options to apply to this operation
/// @param data user data to pass down to this function
/// @param delete_data deleter for user data
/// @param callback to invoke with the result
/// @return True if completes successfully, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_mongodb_collection_t>, realm_string_t, ffi.Pointer<realm_mongodb_find_options_t>, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t, realm_mongodb_callback_t)>(symbol: 'realm_mongo_collection_find_one')
external bool realm_mongo_collection_find_one(
  ffi.Pointer<realm_mongodb_collection_t> collection,
  realm_string_t filter_ejson,
  ffi.Pointer<realm_mongodb_find_options_t> options,
  ffi.Pointer<ffi.Void> data,
  realm_free_userdata_func_t delete_data,
  realm_mongodb_callback_t callback,
);

/// Implement find_one and delete  for mongodb collection
/// @param collection name of the collection to fetch from
/// @param filter_ejson extended json string serialization representing the filter to apply to this operation
/// @param options set of possible options to apply to this operation
/// @param data user data to pass down to this function
/// @param delete_data deleter for user data
/// @param callback to invoke with the result
/// @return True if completes successfully, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_mongodb_collection_t>, realm_string_t, ffi.Pointer<realm_mongodb_find_one_and_modify_options_t>, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t, realm_mongodb_callback_t)>(symbol: 'realm_mongo_collection_find_one_and_delete')
external bool realm_mongo_collection_find_one_and_delete(
  ffi.Pointer<realm_mongodb_collection_t> collection,
  realm_string_t filter_ejson,
  ffi.Pointer<realm_mongodb_find_one_and_modify_options_t> options,
  ffi.Pointer<ffi.Void> data,
  realm_free_userdata_func_t delete_data,
  realm_mongodb_callback_t callback,
);

/// Implement find_one and replace for mongodb collection
/// @param collection name of the collection to fetch from
/// @param filter_ejson extended json string serialization representing the filter to apply to this operation
/// @param replacement_ejson extended json string serialization representing the replacement object to apply to this
/// operation
/// @param options set of possible options to apply to this operation
/// @param data user data to pass down to this function
/// @param delete_data deleter for user data
/// @param callback to invoke with the result
/// @return True if completes successfully, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_mongodb_collection_t>, realm_string_t, realm_string_t, ffi.Pointer<realm_mongodb_find_one_and_modify_options_t>,
        ffi.Pointer<ffi.Void>, realm_free_userdata_func_t, realm_mongodb_callback_t)>(symbol: 'realm_mongo_collection_find_one_and_replace')
external bool realm_mongo_collection_find_one_and_replace(
  ffi.Pointer<realm_mongodb_collection_t> collection,
  realm_string_t filter_ejson,
  realm_string_t replacement_ejson,
  ffi.Pointer<realm_mongodb_find_one_and_modify_options_t> options,
  ffi.Pointer<ffi.Void> data,
  realm_free_userdata_func_t delete_data,
  realm_mongodb_callback_t callback,
);

/// Implement find one and update for mongodb collection
/// @param collection name of the collection to fetch from
/// @param filter_ejson extended json string serialization representing the filter to apply to this operation
/// @param update_ejson extended json string serialization representing the update to apply to this operation
/// @param options set of possible options to apply to this operation
/// @param data user data to pass down to this function
/// @param delete_data deleter for user data
/// @param callback to invoke with the result
/// @return True if completes successfully, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_mongodb_collection_t>, realm_string_t, realm_string_t, ffi.Pointer<realm_mongodb_find_one_and_modify_options_t>,
        ffi.Pointer<ffi.Void>, realm_free_userdata_func_t, realm_mongodb_callback_t)>(symbol: 'realm_mongo_collection_find_one_and_update')
external bool realm_mongo_collection_find_one_and_update(
  ffi.Pointer<realm_mongodb_collection_t> collection,
  realm_string_t filter_ejson,
  realm_string_t update_ejson,
  ffi.Pointer<realm_mongodb_find_one_and_modify_options_t> options,
  ffi.Pointer<ffi.Void> data,
  realm_free_userdata_func_t delete_data,
  realm_mongodb_callback_t callback,
);

/// Get mongo db collection from realm mongo db client
/// @param user ptr to the sync realm user of which we want to retrieve the remote collection for
/// @param service name of the service where the collection will be found
/// @param database name of the database where the collection will be found
/// @param collection name of the collection to fetch
/// @return a ptr to a valid mongodb collection if such collection exists, nullptr otherwise
@ffi.Native<ffi.Pointer<realm_mongodb_collection_t> Function(ffi.Pointer<realm_user_t>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>(
    symbol: 'realm_mongo_collection_get')
external ffi.Pointer<realm_mongodb_collection_t> realm_mongo_collection_get(
  ffi.Pointer<realm_user_t> user,
  ffi.Pointer<ffi.Char> service,
  ffi.Pointer<ffi.Char> database,
  ffi.Pointer<ffi.Char> collection,
);

/// Implement insert_many for mongodb collection
/// @param collection name of the collection to fetch from
/// @param filter_ejson extended json string serialization representing the filter to apply to this operation
/// @param data user data to pass down to this function
/// @param delete_data deleter for user data
/// @param callback to invoke with the result
/// @return True if completes successfully, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_mongodb_collection_t>, realm_string_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t,
        realm_mongodb_callback_t)>(symbol: 'realm_mongo_collection_insert_many')
external bool realm_mongo_collection_insert_many(
  ffi.Pointer<realm_mongodb_collection_t> collection,
  realm_string_t filter_ejson,
  ffi.Pointer<ffi.Void> data,
  realm_free_userdata_func_t delete_data,
  realm_mongodb_callback_t callback,
);

/// Implement insert_one for mongodb collection
/// @param collection name of the collection to fetch from
/// @param filter_ejson extended json string serialization representing the filter to apply to this operation
/// @param data user data to pass down to this function
/// @param delete_data deleter for user data
/// @param callback to invoke with the result
/// @return True if completes successfully, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_mongodb_collection_t>, realm_string_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t,
        realm_mongodb_callback_t)>(symbol: 'realm_mongo_collection_insert_one')
external bool realm_mongo_collection_insert_one(
  ffi.Pointer<realm_mongodb_collection_t> collection,
  realm_string_t filter_ejson,
  ffi.Pointer<ffi.Void> data,
  realm_free_userdata_func_t delete_data,
  realm_mongodb_callback_t callback,
);

/// Implement update_many for mongodb collection
/// @param collection name of the collection to fetch from
/// @param filter_ejson extended json string serialization representing the filter to apply to this operation
/// @param update_ejson extended json string serialization representing the update to apply to this operation
/// @param upsert boolean flag to set for enable or disable upsert for the collection
/// @param data user data to pass down to this function
/// @param delete_data deleter for user data
/// @param callback to invoke with the result
/// @return True if completes successfully, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_mongodb_collection_t>, realm_string_t, realm_string_t, ffi.Bool, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t,
        realm_mongodb_callback_t)>(symbol: 'realm_mongo_collection_update_many')
external bool realm_mongo_collection_update_many(
  ffi.Pointer<realm_mongodb_collection_t> collection,
  realm_string_t filter_ejson,
  realm_string_t update_ejson,
  bool upsert,
  ffi.Pointer<ffi.Void> data,
  realm_free_userdata_func_t delete_data,
  realm_mongodb_callback_t callback,
);

/// Implement update_one for mongodb collection
/// @param collection name of the collection to fetch from
/// @param filter_ejson extended json string serialization representing the filter to apply to this operation
/// @param update_ejson extended json string serialization representing the update to apply to this operation
/// @param upsert boolean flag to set for enable or disable upsert for the collection
/// @param data user data to pass down to this function
/// @param delete_data deleter for user data
/// @param callback to invoke with the result
/// @return True if completes successfully, False otherwise
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_mongodb_collection_t>, realm_string_t, realm_string_t, ffi.Bool, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t,
        realm_mongodb_callback_t)>(symbol: 'realm_mongo_collection_update_one')
external bool realm_mongo_collection_update_one(
  ffi.Pointer<realm_mongodb_collection_t> collection,
  realm_string_t filter_ejson,
  realm_string_t update_ejson,
  bool upsert,
  ffi.Pointer<ffi.Void> data,
  realm_free_userdata_func_t delete_data,
  realm_mongodb_callback_t callback,
);

/// Increment atomically property specified as parameter by value, for the object passed as argument.
/// @param object valid ptr to an object store in the database
/// @param property_key id of the property to change
/// @param value increment for the property passed as argument
/// @return True if not exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_object_t>, realm_property_key_t, ffi.Int64)>(symbol: 'realm_object_add_int')
external bool realm_object_add_int(
  ffi.Pointer<realm_object_t> object,
  int property_key,
  int value,
);

/// Subscribe to notifications for this object.
///
/// @return A non-null pointer if no exception occurred.
@ffi.Native<
    ffi.Pointer<realm_notification_token_t> Function(ffi.Pointer<realm_object_t>, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t,
        ffi.Pointer<realm_key_path_array_t>, realm_on_object_change_func_t)>(symbol: 'realm_object_add_notification_callback')
external ffi.Pointer<realm_notification_token_t> realm_object_add_notification_callback(
  ffi.Pointer<realm_object_t> arg0,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
  ffi.Pointer<realm_key_path_array_t> key_path_array,
  realm_on_object_change_func_t on_change,
);

/// Get a `realm_link_t` representing a link to @a object.
///
/// This function cannot fail.
@ffi.Native<realm_link_t Function(ffi.Pointer<realm_object_t>)>(symbol: 'realm_object_as_link')
external realm_link_t realm_object_as_link(
  ffi.Pointer<realm_object_t> object,
);

/// Get the column keys for the properties that were modified in an object
/// notification.
///
/// This function cannot fail.
///
/// @param out_modified Where the column keys should be written. May be NULL.
/// @param max The maximum number of column keys to write.
/// @return The number of column keys written to @a out_modified, or the number
/// of modified properties if @a out_modified is NULL.
@ffi.Native<ffi.Size Function(ffi.Pointer<realm_object_changes_t>, ffi.Pointer<realm_property_key_t>, ffi.Size)>(
    symbol: 'realm_object_changes_get_modified_properties')
external int realm_object_changes_get_modified_properties(
  ffi.Pointer<realm_object_changes_t> arg0,
  ffi.Pointer<realm_property_key_t> out_modified,
  int max,
);

/// Get the number of properties that were modified in an object notification.
///
/// This function cannot fail.
@ffi.Native<ffi.Size Function(ffi.Pointer<realm_object_changes_t>)>(symbol: 'realm_object_changes_get_num_modified_properties')
external int realm_object_changes_get_num_modified_properties(
  ffi.Pointer<realm_object_changes_t> arg0,
);

/// True if an object notification indicates that the object was deleted.
///
/// This function cannot fail.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_object_changes_t>)>(symbol: 'realm_object_changes_is_deleted')
external bool realm_object_changes_is_deleted(
  ffi.Pointer<realm_object_changes_t> arg0,
);

/// Create an object in a class without a primary key.
///
/// @return A non-NULL pointer if the object was created successfully.
@ffi.Native<ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_t>, realm_class_key_t)>(symbol: 'realm_object_create')
external ffi.Pointer<realm_object_t> realm_object_create(
  ffi.Pointer<realm_t> arg0,
  int arg1,
);

/// Create an object in a class with a primary key. Will not succeed if an
/// object with the given primary key value already exists.
///
/// @return A non-NULL pointer if the object was created successfully.
@ffi.Native<ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_t>, realm_class_key_t, realm_value_t)>(symbol: 'realm_object_create_with_primary_key')
external ffi.Pointer<realm_object_t> realm_object_create_with_primary_key(
  ffi.Pointer<realm_t> arg0,
  int arg1,
  realm_value_t pk,
);

/// Delete a realm object.
///
/// Note: This does not call `realm_release()` on the `realm_object_t` instance.
///
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_object_t>)>(symbol: 'realm_object_delete')
external bool realm_object_delete(
  ffi.Pointer<realm_object_t> arg0,
);

/// Find all objects in class.
///
/// Note: This is faster than running a query matching all objects (such as
/// "TRUEPREDICATE").
///
/// @return A non-NULL pointer if no exception was thrown.
@ffi.Native<ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_t>, realm_class_key_t)>(symbol: 'realm_object_find_all')
external ffi.Pointer<realm_results_t> realm_object_find_all(
  ffi.Pointer<realm_t> arg0,
  int arg1,
);

/// Find an object with a particular primary key value.
///
/// @param out_found A pointer to a boolean that will be set to true or false if
/// no error occurred.
/// @return A non-NULL pointer if the object was found and no exception occurred.
@ffi.Native<ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_t>, realm_class_key_t, realm_value_t, ffi.Pointer<ffi.Bool>)>(
    symbol: 'realm_object_find_with_primary_key')
external ffi.Pointer<realm_object_t> realm_object_find_with_primary_key(
  ffi.Pointer<realm_t> arg0,
  int arg1,
  realm_value_t pk,
  ffi.Pointer<ffi.Bool> out_found,
);

/// Get an object from a thread-safe reference, potentially originating in a
/// different `realm_t` instance
@ffi.Native<ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_t>, ffi.Pointer<realm_thread_safe_reference_t>)>(
    symbol: 'realm_object_from_thread_safe_reference')
external ffi.Pointer<realm_object_t> realm_object_from_thread_safe_reference(
  ffi.Pointer<realm_t> arg0,
  ffi.Pointer<realm_thread_safe_reference_t> arg1,
);

/// Get the key for this object.
///
/// This function cannot fail.
@ffi.Native<realm_object_key_t Function(ffi.Pointer<realm_object_t>)>(symbol: 'realm_object_get_key')
external int realm_object_get_key(
  ffi.Pointer<realm_object_t> object,
);

/// Create an object in a class with a primary key. If an object with the given
/// primary key value already exists, that object will be returned.
///
/// @return A non-NULL pointer if the object was found/created successfully.
@ffi.Native<ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_t>, realm_class_key_t, realm_value_t, ffi.Pointer<ffi.Bool>)>(
    symbol: 'realm_object_get_or_create_with_primary_key')
external ffi.Pointer<realm_object_t> realm_object_get_or_create_with_primary_key(
  ffi.Pointer<realm_t> arg0,
  int arg1,
  realm_value_t pk,
  ffi.Pointer<ffi.Bool> did_create,
);

/// Get the parent object for the object passed as argument. Only works for embedded objects.
/// @return true, if no errors occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_object_t>, ffi.Pointer<ffi.Pointer<realm_object_t>>, ffi.Pointer<realm_class_key_t>)>(
    symbol: 'realm_object_get_parent')
external bool realm_object_get_parent(
  ffi.Pointer<realm_object_t> object,
  ffi.Pointer<ffi.Pointer<realm_object_t>> parent,
  ffi.Pointer<realm_class_key_t> class_key,
);

/// Get the table for this object.
///
/// This function cannot fail.
@ffi.Native<realm_class_key_t Function(ffi.Pointer<realm_object_t>)>(symbol: 'realm_object_get_table')
external int realm_object_get_table(
  ffi.Pointer<realm_object_t> object,
);

/// True if this object still exists in the realm.
///
/// This function cannot fail.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_object_t>)>(symbol: 'realm_object_is_valid')
external bool realm_object_is_valid(
  ffi.Pointer<realm_object_t> arg0,
);

/// Resolve the Realm object in the provided Realm.
///
/// This is equivalent to producing a thread-safe reference and resolving it in the target realm.
///
/// If the object can be resolved in the target realm, '*resolved' points to the new object
/// If the object cannot be resolved in the target realm, '*resolved' will be null.
/// @return True if no exception occurred (except exceptions that may normally occur if resolution fails)
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_object_t>, ffi.Pointer<realm_t>, ffi.Pointer<ffi.Pointer<realm_object_t>>)>(symbol: 'realm_object_resolve_in')
external bool realm_object_resolve_in(
  ffi.Pointer<realm_object_t> live_object,
  ffi.Pointer<realm_t> target_realm,
  ffi.Pointer<ffi.Pointer<realm_object_t>> resolved,
);

/// Serializes an object to json and returns it as string. Serializes a single level of properties only.
///
/// @return a json-serialized representation of the object.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<realm_object_t>)>(symbol: 'realm_object_to_string')
external ffi.Pointer<ffi.Char> realm_object_to_string(
  ffi.Pointer<realm_object_t> arg0,
);

/// Open a Realm file.
///
/// @param config Realm configuration. If the Realm is already opened on another
/// thread, validate that the given configuration is compatible
/// with the existing one.
/// @return If successful, the Realm object. Otherwise, NULL.
@ffi.Native<ffi.Pointer<realm_t> Function(ffi.Pointer<realm_config_t>)>(symbol: 'realm_open')
external ffi.Pointer<realm_t> realm_open(
  ffi.Pointer<realm_config_t> config,
);

/// Create a task that will open a realm with the specific configuration
/// and also download all changes from the sync server.
///
/// Use @a realm_async_open_task_start() to start the download process.
@ffi.Native<ffi.Pointer<realm_async_open_task_t> Function(ffi.Pointer<realm_config_t>)>(symbol: 'realm_open_synchronized')
external ffi.Pointer<realm_async_open_task_t> realm_open_synchronized(
  ffi.Pointer<realm_config_t> arg0,
);

/// Parse a query string and append it to an existing query via logical &&.
/// The query string applies to the same table and Realm as the existing query.
///
/// If the query failed to parse, the parser error is available from
/// `realm_get_last_error()`.
///
/// @param query_string A zero-terminated string in the Realm Query Language,
/// optionally containing argument placeholders (`$0`, `$1`,
/// etc.).
/// @param num_args The number of arguments for this query.
/// @param args A pointer to a list of argument values.
/// @return A non-null pointer if the query was successfully parsed and no
/// exception occurred.
@ffi.Native<ffi.Pointer<realm_query_t> Function(ffi.Pointer<realm_query_t>, ffi.Pointer<ffi.Char>, ffi.Size, ffi.Pointer<realm_query_arg_t>)>(
    symbol: 'realm_query_append_query')
external ffi.Pointer<realm_query_t> realm_query_append_query(
  ffi.Pointer<realm_query_t> arg0,
  ffi.Pointer<ffi.Char> query_string,
  int num_args,
  ffi.Pointer<realm_query_arg_t> args,
);

/// Count the number of objects found by this query.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_query_t>, ffi.Pointer<ffi.Size>)>(symbol: 'realm_query_count')
external bool realm_query_count(
  ffi.Pointer<realm_query_t> arg0,
  ffi.Pointer<ffi.Size> out_count,
);

/// Delete all objects matched by a query.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_query_t>)>(symbol: 'realm_query_delete_all')
external bool realm_query_delete_all(
  ffi.Pointer<realm_query_t> arg0,
);

/// Produce a results object for this query.
///
/// Note: This does not actually run the query until the results are accessed in
/// some way.
///
/// @return A non-null pointer if no exception occurred.
@ffi.Native<ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_query_t>)>(symbol: 'realm_query_find_all')
external ffi.Pointer<realm_results_t> realm_query_find_all(
  ffi.Pointer<realm_query_t> arg0,
);

/// Return the first object matched by this query.
///
/// Note: This function can only produce objects, not values. Use the
/// `realm_results_t` returned by `realm_query_find_all()` to retrieve
/// values from a list of primitive values.
///
/// @param out_value Where to write the result, if any object matched the query.
/// May be NULL.
/// @param out_found Where to write whether the object was found. May be NULL.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_query_t>, ffi.Pointer<realm_value_t>, ffi.Pointer<ffi.Bool>)>(symbol: 'realm_query_find_first')
external bool realm_query_find_first(
  ffi.Pointer<realm_query_t> arg0,
  ffi.Pointer<realm_value_t> out_value,
  ffi.Pointer<ffi.Bool> out_found,
);

/// Get textual representation of query
///
/// @return a string containing the description. The string memory is managed by the query object.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<realm_query_t>)>(symbol: 'realm_query_get_description')
external ffi.Pointer<ffi.Char> realm_query_get_description(
  ffi.Pointer<realm_query_t> arg0,
);

/// Parse a query string and bind it to a table.
///
/// If the query failed to parse, the parser error is available from
/// `realm_get_last_error()`.
///
/// @param target_table The table on which to run this query.
/// @param query_string A zero-terminated string in the Realm Query Language,
/// optionally containing argument placeholders (`$0`, `$1`,
/// etc.).
/// @param num_args The number of arguments for this query.
/// @param args A pointer to a list of argument values.
/// @return A non-null pointer if the query was successfully parsed and no
/// exception occurred.
@ffi.Native<ffi.Pointer<realm_query_t> Function(ffi.Pointer<realm_t>, realm_class_key_t, ffi.Pointer<ffi.Char>, ffi.Size, ffi.Pointer<realm_query_arg_t>)>(
    symbol: 'realm_query_parse')
external ffi.Pointer<realm_query_t> realm_query_parse(
  ffi.Pointer<realm_t> arg0,
  int target_table,
  ffi.Pointer<ffi.Char> query_string,
  int num_args,
  ffi.Pointer<realm_query_arg_t> args,
);

/// Parse a query string and bind it to a list.
///
/// If the query failed to parse, the parser error is available from
/// `realm_get_last_error()`.
///
/// @param target_list The list on which to run this query.
/// @param query_string A string in the Realm Query Language, optionally
/// containing argument placeholders (`$0`, `$1`, etc.).
/// @param num_args The number of arguments for this query.
/// @param args A pointer to a list of argument values.
/// @return A non-null pointer if the query was successfully parsed and no
/// exception occurred.
@ffi.Native<ffi.Pointer<realm_query_t> Function(ffi.Pointer<realm_list_t>, ffi.Pointer<ffi.Char>, ffi.Size, ffi.Pointer<realm_query_arg_t>)>(
    symbol: 'realm_query_parse_for_list')
external ffi.Pointer<realm_query_t> realm_query_parse_for_list(
  ffi.Pointer<realm_list_t> target_list,
  ffi.Pointer<ffi.Char> query_string,
  int num_args,
  ffi.Pointer<realm_query_arg_t> args,
);

/// Parse a query string and bind it to another query result.
///
/// If the query failed to parse, the parser error is available from
/// `realm_get_last_error()`.
///
/// @param target_results The results on which to run this query.
/// @param query_string A zero-terminated string in the Realm Query Language,
/// optionally containing argument placeholders (`$0`, `$1`,
/// etc.).
/// @param num_args The number of arguments for this query.
/// @param args A pointer to a list of argument values.
/// @return A non-null pointer if the query was successfully parsed and no
/// exception occurred.
@ffi.Native<ffi.Pointer<realm_query_t> Function(ffi.Pointer<realm_results_t>, ffi.Pointer<ffi.Char>, ffi.Size, ffi.Pointer<realm_query_arg_t>)>(
    symbol: 'realm_query_parse_for_results')
external ffi.Pointer<realm_query_t> realm_query_parse_for_results(
  ffi.Pointer<realm_results_t> target_results,
  ffi.Pointer<ffi.Char> query_string,
  int num_args,
  ffi.Pointer<realm_query_arg_t> args,
);

/// Parse a query string and bind it to a set.
///
/// If the query failed to parse, the parser error is available from
/// `realm_get_last_error()`.
///
/// @param target_set The set on which to run this query.
/// @param query_string A string in the Realm Query Language, optionally
/// containing argument placeholders (`$0`, `$1`, etc.).
/// @param num_args The number of arguments for this query.
/// @param args A pointer to a list of argument values.
/// @return A non-null pointer if the query was successfully parsed and no
/// exception occurred.
@ffi.Native<ffi.Pointer<realm_query_t> Function(ffi.Pointer<realm_set_t>, ffi.Pointer<ffi.Char>, ffi.Size, ffi.Pointer<realm_query_arg_t>)>(
    symbol: 'realm_query_parse_for_set')
external ffi.Pointer<realm_query_t> realm_query_parse_for_set(
  ffi.Pointer<realm_set_t> target_set,
  ffi.Pointer<ffi.Char> query_string,
  int num_args,
  ffi.Pointer<realm_query_arg_t> args,
);

/// Refresh the view of the realm file.
///
/// If another process or thread has made changes to the realm file, this causes
/// those changes to become visible in this realm instance.
///
/// This calls `advance_read()` at the Core layer.
///
/// @return True if no exceptions are thrown, false otherwise.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>, ffi.Pointer<ffi.Bool>)>(symbol: 'realm_refresh')
external bool realm_refresh(
  ffi.Pointer<realm_t> arg0,
  ffi.Pointer<ffi.Bool> did_refresh,
);

/// In case of exception thrown in user code callbacks, this api will allow the sdk to store the user code exception
/// and retrieve a it later via realm_get_last_error.
/// Most importantly the SDK is responsible to handle the memory pointed by user_code_error.
/// @param usercode_error pointer representing whatever object the SDK treats as exception/error.
@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>(symbol: 'realm_register_user_code_callback_error')
external void realm_register_user_code_callback_error(
  ffi.Pointer<ffi.Void> usercode_error,
);

/// Free any Realm C Wrapper object.
///
/// Note: Any pointer returned from a library function is owned by the caller.
/// The caller is responsible for calling `realm_release()`. The only
/// exception from this is C++ bridge functions that return `void*`, with
/// the prefix `_realm`.
///
/// Note: C++ destructors are typically `noexcept`, so it is likely that an
/// exception will crash the process.
///
/// @param ptr A pointer to a Realm C Wrapper object. May be NULL.
@ffi.Native<ffi.Void Function(ffi.Pointer<ffi.Void>)>(symbol: 'realm_release')
external void realm_release(
  ffi.Pointer<ffi.Void> ptr,
);

/// Find and delete the table passed as parementer for the realm instance passed to this function.
/// @param table_name for the table the user wants to delete
/// @param table_deleted in order to indicate if the table was actually deleted from realm
/// @return true if no error has occurred, false otherwise
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Bool>)>(symbol: 'realm_remove_table')
external bool realm_remove_table(
  ffi.Pointer<realm_t> arg0,
  ffi.Pointer<ffi.Char> table_name,
  ffi.Pointer<ffi.Bool> table_deleted,
);

@ffi.Native<
    ffi.Pointer<realm_notification_token_t> Function(ffi.Pointer<realm_results_t>, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t,
        ffi.Pointer<realm_key_path_array_t>, realm_on_collection_change_func_t)>(symbol: 'realm_results_add_notification_callback')
external ffi.Pointer<realm_notification_token_t> realm_results_add_notification_callback(
  ffi.Pointer<realm_results_t> arg0,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
  ffi.Pointer<realm_key_path_array_t> key_path_array,
  realm_on_collection_change_func_t arg4,
);

/// Compute the average value of a property in the results.
///
/// Note: For numeric columns, the average is always converted to double.
///
/// @param out_average Where to write the result.
/// @param out_found Set to true if there are matching rows.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_results_t>, realm_property_key_t, ffi.Pointer<realm_value_t>, ffi.Pointer<ffi.Bool>)>(
    symbol: 'realm_results_average')
external bool realm_results_average(
  ffi.Pointer<realm_results_t> arg0,
  int arg1,
  ffi.Pointer<realm_value_t> out_average,
  ffi.Pointer<ffi.Bool> out_found,
);

/// Count the number of results.
///
/// If the result is "live" (not a snapshot), this may rerun the query if things
/// have changed.
///
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_results_t>, ffi.Pointer<ffi.Size>)>(symbol: 'realm_results_count')
external bool realm_results_count(
  ffi.Pointer<realm_results_t> arg0,
  ffi.Pointer<ffi.Size> out_count,
);

/// Delete all objects in the result.
///
/// If the result if "live" (not a snapshot), this may rerun the query if things
/// have changed.
///
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_results_t>)>(symbol: 'realm_results_delete_all')
external bool realm_results_delete_all(
  ffi.Pointer<realm_results_t> arg0,
);

/// Create a new results object by removing duplicates
///
/// @param distinct_string Specifies a distinct condition. It has the format
/// <param> ["," <param>]*
/// <param> ::= <prop> ["." <prop>]*
/// @return A non-null pointer if no exception occurred.
@ffi.Native<ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_results_t>, ffi.Pointer<ffi.Char>)>(symbol: 'realm_results_distinct')
external ffi.Pointer<realm_results_t> realm_results_distinct(
  ffi.Pointer<realm_results_t> results,
  ffi.Pointer<ffi.Char> distinct_string,
);

/// Create a new results object by further filtering existing result.
///
/// @return A non-null pointer if no exception occurred.
@ffi.Native<ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_results_t>, ffi.Pointer<realm_query_t>)>(symbol: 'realm_results_filter')
external ffi.Pointer<realm_results_t> realm_results_filter(
  ffi.Pointer<realm_results_t> arg0,
  ffi.Pointer<realm_query_t> arg1,
);

/// Find the index for the value passed as parameter inside realm results pointer passed a input parameter.
/// @param value the value to find inside the realm results
/// @param out_index the index where the object has been found, or realm::not_found
/// @param out_found boolean indicating if the value has been found or not
/// @return true if no error occurred, false otherwise
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_results_t>, ffi.Pointer<realm_value_t>, ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Bool>)>(
    symbol: 'realm_results_find')
external bool realm_results_find(
  ffi.Pointer<realm_results_t> arg0,
  ffi.Pointer<realm_value_t> value,
  ffi.Pointer<ffi.Size> out_index,
  ffi.Pointer<ffi.Bool> out_found,
);

/// Find the index for the realm object passed as parameter inside realm results pointer passed a input parameter.
/// @param value the value to find inside the realm results
/// @param out_index the index where the object has been found, or realm::not_found
/// @param out_found boolean indicating if the value has been found or not
/// @return true if no error occurred, false otherwise
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_results_t>, ffi.Pointer<realm_object_t>, ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Bool>)>(
    symbol: 'realm_results_find_object')
external bool realm_results_find_object(
  ffi.Pointer<realm_results_t> arg0,
  ffi.Pointer<realm_object_t> value,
  ffi.Pointer<ffi.Size> out_index,
  ffi.Pointer<ffi.Bool> out_found,
);

/// Get an results object from a thread-safe reference, potentially originating
/// in a different `realm_t` instance
@ffi.Native<ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_t>, ffi.Pointer<realm_thread_safe_reference_t>)>(
    symbol: 'realm_results_from_thread_safe_reference')
external ffi.Pointer<realm_results_t> realm_results_from_thread_safe_reference(
  ffi.Pointer<realm_t> arg0,
  ffi.Pointer<realm_thread_safe_reference_t> arg1,
);

/// Get the matching element at @a index in the results.
///
/// If the result is "live" (not a snapshot), this may rerun the query if things
/// have changed.
///
/// Note: The bound returned by `realm_results_count()` for a non-snapshot result
/// is not a reliable way to iterate over elements in the result, because
/// the result will be live-updated if changes are made in each iteration
/// that may change the number of query results or even change the
/// ordering. In other words, this method should probably only be used with
/// snapshot results.
///
/// @return True if no exception occurred (including out-of-bounds).
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_results_t>, ffi.Size, ffi.Pointer<realm_value_t>)>(symbol: 'realm_results_get')
external bool realm_results_get(
  ffi.Pointer<realm_results_t> arg0,
  int index,
  ffi.Pointer<realm_value_t> out_value,
);

/// Get the matching object at @a index in the results.
///
/// If the result is "live" (not a snapshot), this may rerun the query if things
/// have changed.
///
/// Note: The bound returned by `realm_results_count()` for a non-snapshot result
/// is not a reliable way to iterate over elements in the result, because
/// the result will be live-updated if changes are made in each iteration
/// that may change the number of query results or even change the
/// ordering. In other words, this method should probably only be used with
/// snapshot results.
///
/// @return An instance of `realm_object_t` if no exception occurred.
@ffi.Native<ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_results_t>, ffi.Size)>(symbol: 'realm_results_get_object')
external ffi.Pointer<realm_object_t> realm_results_get_object(
  ffi.Pointer<realm_results_t> arg0,
  int index,
);

/// Return the query associated to the results passed as argument.
///
/// @param results the ptr to a valid results object.
/// @return a valid ptr to realm_query_t if no error has occurred
@ffi.Native<ffi.Pointer<realm_query_t> Function(ffi.Pointer<realm_results_t>)>(symbol: 'realm_results_get_query')
external ffi.Pointer<realm_query_t> realm_results_get_query(
  ffi.Pointer<realm_results_t> results,
);

/// Set the boolean passed as argument to true or false whether the realm_results passed is valid or not
/// @return true/false if no exception has occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_results_t>, ffi.Pointer<ffi.Bool>)>(symbol: 'realm_results_is_valid')
external bool realm_results_is_valid(
  ffi.Pointer<realm_results_t> arg0,
  ffi.Pointer<ffi.Bool> arg1,
);

/// Create a new results object by limiting the number of items
///
/// @param max_count Specifies the number of elements the new result can have at most
/// @return A non-null pointer if no exception occurred.
@ffi.Native<ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_results_t>, ffi.Size)>(symbol: 'realm_results_limit')
external ffi.Pointer<realm_results_t> realm_results_limit(
  ffi.Pointer<realm_results_t> results,
  int max_count,
);

/// Compute the maximum value of a property in the results.
///
/// @param out_max Where to write the result, if there were matching rows.
/// @param out_found Set to true if there are matching rows.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_results_t>, realm_property_key_t, ffi.Pointer<realm_value_t>, ffi.Pointer<ffi.Bool>)>(
    symbol: 'realm_results_max')
external bool realm_results_max(
  ffi.Pointer<realm_results_t> arg0,
  int arg1,
  ffi.Pointer<realm_value_t> out_max,
  ffi.Pointer<ffi.Bool> out_found,
);

/// Compute the minimum value of a property in the results.
///
/// @param out_min Where to write the result, if there were matching rows.
/// @param out_found Set to true if there are matching rows.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_results_t>, realm_property_key_t, ffi.Pointer<realm_value_t>, ffi.Pointer<ffi.Bool>)>(
    symbol: 'realm_results_min')
external bool realm_results_min(
  ffi.Pointer<realm_results_t> arg0,
  int arg1,
  ffi.Pointer<realm_value_t> out_min,
  ffi.Pointer<ffi.Bool> out_found,
);

/// Map the Results into a live Realm instance.
///
/// This is equivalent to producing a thread-safe reference and resolving it in the live realm.
///
/// @return A live copy of the Results.
@ffi.Native<ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_results_t>, ffi.Pointer<realm_t>)>(symbol: 'realm_results_resolve_in')
external ffi.Pointer<realm_results_t> realm_results_resolve_in(
  ffi.Pointer<realm_results_t> from_results,
  ffi.Pointer<realm_t> target_realm,
);

/// Return a snapshot of the results that never automatically updates.
///
/// The returned result is suitable for use with `realm_results_count()` +
/// `realm_results_get()`.
@ffi.Native<ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_results_t>)>(symbol: 'realm_results_snapshot')
external ffi.Pointer<realm_results_t> realm_results_snapshot(
  ffi.Pointer<realm_results_t> arg0,
);

/// Create a new results object by further sorting existing result.
///
/// @param sort_string Specifies a sort condition. It has the format
/// <param> ["," <param>]*
/// <param> ::= <prop> ["." <prop>]* <direction>,
/// <direction> ::= "ASCENDING" | "DESCENDING"
/// @return A non-null pointer if no exception occurred.
@ffi.Native<ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_results_t>, ffi.Pointer<ffi.Char>)>(symbol: 'realm_results_sort')
external ffi.Pointer<realm_results_t> realm_results_sort(
  ffi.Pointer<realm_results_t> results,
  ffi.Pointer<ffi.Char> sort_string,
);

/// Compute the sum value of a property in the results.
///
/// @param out_sum Where to write the result. Zero if no rows matched.
/// @param out_found Set to true if there are matching rows.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_results_t>, realm_property_key_t, ffi.Pointer<realm_value_t>, ffi.Pointer<ffi.Bool>)>(
    symbol: 'realm_results_sum')
external bool realm_results_sum(
  ffi.Pointer<realm_results_t> arg0,
  int arg1,
  ffi.Pointer<realm_value_t> out_sum,
  ffi.Pointer<ffi.Bool> out_found,
);

/// Roll back a write transaction.
///
/// @return True if the rollback succeeded and no exceptions were thrown.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>)>(symbol: 'realm_rollback')
external bool realm_rollback(
  ffi.Pointer<realm_t> arg0,
);

/// Get the scheduler used by frozen realms. This scheduler does not support
/// notifications, and does not perform any thread checking.
///
/// This function is thread-safe, and cannot fail.
@ffi.Native<ffi.Pointer<realm_scheduler_t> Function()>(symbol: 'realm_scheduler_get_frozen')
external ffi.Pointer<realm_scheduler_t> realm_scheduler_get_frozen();

/// Returns true if there is a default scheduler implementation for the current
/// platform, or one has been set with `realm_scheduler_set_default_factory()`.
///
/// If there is no default factory, and no scheduler is provided in the config,
/// `realm_open()` will fail. Note that `realm_scheduler_get_frozen()` always
/// returns a valid scheduler.
///
/// This function is thread-safe, and cannot fail.
@ffi.Native<ffi.Bool Function()>(symbol: 'realm_scheduler_has_default_factory')
external bool realm_scheduler_has_default_factory();

/// Create an instance of the default scheduler for the current platform,
/// normally confined to the calling thread.
@ffi.Native<ffi.Pointer<realm_scheduler_t> Function()>(symbol: 'realm_scheduler_make_default')
external ffi.Pointer<realm_scheduler_t> realm_scheduler_make_default();

/// Create a custom scheduler object from callback functions.
///
/// @param notify Function which will be called whenever the scheduler has work
/// to do. Each call to this should trigger a call to
/// `realm_scheduler_perform_work()` from within the scheduler's
/// event loop. This function must be thread-safe, or NULL, in
/// which case the scheduler is considered unable to deliver
/// notifications.
/// @param is_on_thread Function to return true if called from the same thread as
/// the scheduler. This function must be thread-safe.
/// @param can_deliver_notifications Function to return true if the scheduler can
/// support `notify()`. This function does not
/// need to be thread-safe.
@ffi.Native<
    ffi.Pointer<realm_scheduler_t> Function(
        ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t,
        realm_scheduler_notify_func_t,
        realm_scheduler_is_on_thread_func_t,
        realm_scheduler_is_same_as_func_t,
        realm_scheduler_can_deliver_notifications_func_t)>(symbol: 'realm_scheduler_new')
external ffi.Pointer<realm_scheduler_t> realm_scheduler_new(
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
  realm_scheduler_notify_func_t notify,
  realm_scheduler_is_on_thread_func_t is_on_thread,
  realm_scheduler_is_same_as_func_t is_same_as,
  realm_scheduler_can_deliver_notifications_func_t can_deliver_notifications,
);

/// Performs all of the pending work for the given scheduler.
///
/// This function must be called from within the scheduler's event loop. It must
/// be called each time the notify callback passed to the scheduler
/// is invoked.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_work_queue_t>)>(symbol: 'realm_scheduler_perform_work')
external void realm_scheduler_perform_work(
  ffi.Pointer<realm_work_queue_t> arg0,
);

/// For platforms with no default scheduler implementation, register a factory
/// function which can produce custom schedulers. If there is a platform-specific
/// scheduler, this function will fail. If a custom scheduler is desired for
/// platforms that already have a default scheduler implementation, the caller
/// must call `realm_open()` with a config that indicates the desired scheduler.
///
/// The provided callback may produce a scheduler by calling
/// `realm_scheduler_new()`.
///
/// This function is thread-safe, but should generally only be called once.
@ffi.Native<ffi.Bool Function(ffi.Pointer<ffi.Void>, realm_free_userdata_func_t, realm_scheduler_default_factory_func_t)>(
    symbol: 'realm_scheduler_set_default_factory')
external bool realm_scheduler_set_default_factory(
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
  realm_scheduler_default_factory_func_t arg2,
);

/// Create a new schema from classes and their properties.
///
/// Note: This function does not validate the schema.
///
/// Note: `realm_class_key_t` and `realm_property_key_t` values inside
/// `realm_class_info_t` and `realm_property_info_t` are unused when
/// defining the schema. Call `realm_get_schema()` to obtain the values for
/// these fields in an open realm.
///
/// @return True if allocation of the schema structure succeeded.
@ffi.Native<ffi.Pointer<realm_schema_t> Function(ffi.Pointer<realm_class_info_t>, ffi.Size, ffi.Pointer<ffi.Pointer<realm_property_info_t>>)>(
    symbol: 'realm_schema_new')
external ffi.Pointer<realm_schema_t> realm_schema_new(
  ffi.Pointer<realm_class_info_t> classes,
  int num_classes,
  ffi.Pointer<ffi.Pointer<realm_property_info_t>> class_properties,
);

/// Rename a property for the schame  of the open realm.
/// @param realm The realm for which the property schema has to be renamed
/// @param schema The schema to modifies
/// @param object_type type of the object to modify
/// @param old_name old name of the property
/// @param new_name new name of the property
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>, ffi.Pointer<realm_schema_t>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>(
    symbol: 'realm_schema_rename_property')
external bool realm_schema_rename_property(
  ffi.Pointer<realm_t> realm,
  ffi.Pointer<realm_schema_t> schema,
  ffi.Pointer<ffi.Char> object_type,
  ffi.Pointer<ffi.Char> old_name,
  ffi.Pointer<ffi.Char> new_name,
);

/// Validate the schema.
///
/// @param validation_mode A bitwise combination of values from the
/// enum realm_schema_validation_mode.
///
/// @return True if the schema passed validation. If validation failed,
/// `realm_get_last_error()` will produce an error describing the
/// validation failure.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_schema_t>, ffi.Uint64)>(symbol: 'realm_schema_validate')
external bool realm_schema_validate(
  ffi.Pointer<realm_schema_t> arg0,
  int validation_mode,
);

/// Subscribe to notifications for this object.
///
/// @return A non-null pointer if no exception occurred.
@ffi.Native<
    ffi.Pointer<realm_notification_token_t> Function(ffi.Pointer<realm_set_t>, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t,
        ffi.Pointer<realm_key_path_array_t>, realm_on_collection_change_func_t)>(symbol: 'realm_set_add_notification_callback')
external ffi.Pointer<realm_notification_token_t> realm_set_add_notification_callback(
  ffi.Pointer<realm_set_t> arg0,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
  ffi.Pointer<realm_key_path_array_t> key_path_array,
  realm_on_collection_change_func_t on_change,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_t>, ffi.Bool)>(symbol: 'realm_set_auto_refresh')
external void realm_set_auto_refresh(
  ffi.Pointer<realm_t> realm,
  bool enable,
);

/// Clear a set of values.
///
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_set_t>)>(symbol: 'realm_set_clear')
external bool realm_set_clear(
  ffi.Pointer<realm_set_t> arg0,
);

/// Create an embedded object in a given property.
///
/// @return A non-NULL pointer if the object was created successfully.
@ffi.Native<ffi.Pointer<realm_object_t> Function(ffi.Pointer<realm_object_t>, realm_property_key_t)>(symbol: 'realm_set_embedded')
external ffi.Pointer<realm_object_t> realm_set_embedded(
  ffi.Pointer<realm_object_t> arg0,
  int arg1,
);

/// Erase an element from a set.
///
/// If the element does not exist in the set, this function does nothing (and
/// does not report an error).
///
/// @param value The value to erase.
/// @param out_erased If non-null, will be set to true if the element was found
/// and erased, and otherwise set to false.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_set_t>, realm_value_t, ffi.Pointer<ffi.Bool>)>(symbol: 'realm_set_erase')
external bool realm_set_erase(
  ffi.Pointer<realm_set_t> arg0,
  realm_value_t value,
  ffi.Pointer<ffi.Bool> out_erased,
);

/// Find an element in a set.
///
/// If @a value has a type that is incompatible with the set, it will be reported
/// as not existing in the set.
///
/// @param value The value to look for in the set.
/// @param out_index If non-null, and the element is found, this will be
/// populated with the index of the found element in the set.
/// @param out_found If non-null, will be set to true if the element was found,
/// otherwise will be set to false.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_set_t>, realm_value_t, ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Bool>)>(symbol: 'realm_set_find')
external bool realm_set_find(
  ffi.Pointer<realm_set_t> arg0,
  realm_value_t value,
  ffi.Pointer<ffi.Size> out_index,
  ffi.Pointer<ffi.Bool> out_found,
);

/// Get an set from a thread-safe reference, potentially originating in a
/// different `realm_t` instance
@ffi.Native<ffi.Pointer<realm_set_t> Function(ffi.Pointer<realm_t>, ffi.Pointer<realm_thread_safe_reference_t>)>(symbol: 'realm_set_from_thread_safe_reference')
external ffi.Pointer<realm_set_t> realm_set_from_thread_safe_reference(
  ffi.Pointer<realm_t> arg0,
  ffi.Pointer<realm_thread_safe_reference_t> arg1,
);

/// Get the value at @a index.
///
/// Note that elements in a set move around arbitrarily when other elements are
/// inserted/removed.
///
/// @param out_value The resulting value, if no error occurred. May be NULL,
/// though nonsensical.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_set_t>, ffi.Size, ffi.Pointer<realm_value_t>)>(symbol: 'realm_set_get')
external bool realm_set_get(
  ffi.Pointer<realm_set_t> arg0,
  int index,
  ffi.Pointer<realm_value_t> out_value,
);

/// Get the property that this set came from.
///
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_set_t>, ffi.Pointer<realm_property_info_t>)>(symbol: 'realm_set_get_property')
external bool realm_set_get_property(
  ffi.Pointer<realm_set_t> arg0,
  ffi.Pointer<realm_property_info_t> out_property_info,
);

/// Insert an element in a set.
///
/// If the element is already in the set, this function does nothing (and does
/// not report an error).
///
/// @param value The value to insert.
/// @param out_index If non-null, will be set to the index of the inserted
/// element, or the index of the existing element.
/// @param out_inserted If non-null, will be set to true if the element did not
/// already exist in the set. Otherwise set to false.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_set_t>, realm_value_t, ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Bool>)>(symbol: 'realm_set_insert')
external bool realm_set_insert(
  ffi.Pointer<realm_set_t> arg0,
  realm_value_t value,
  ffi.Pointer<ffi.Size> out_index,
  ffi.Pointer<ffi.Bool> out_inserted,
);

/// Check if a set is valid.
///
/// @return True if the set is valid.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_set_t>)>(symbol: 'realm_set_is_valid')
external bool realm_set_is_valid(
  ffi.Pointer<realm_set_t> arg0,
);

/// Install the default logger
@ffi.Native<ffi.Void Function(realm_log_func_t, ffi.Int32, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(symbol: 'realm_set_log_callback')
external void realm_set_log_callback(
  realm_log_func_t arg0,
  int arg1,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

@ffi.Native<ffi.Void Function(ffi.Int32)>(symbol: 'realm_set_log_level')
external void realm_set_log_level(
  int arg0,
);

/// In a set of objects, delete all objects in the set and clear the set. In a
/// set of values, clear the set.
///
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_set_t>)>(symbol: 'realm_set_remove_all')
external bool realm_set_remove_all(
  ffi.Pointer<realm_set_t> arg0,
);

/// Resolve the set in the context of a given Realm instance.
///
/// This is equivalent to producing a thread-safe reference and resolving it in the frozen realm.
///
/// If resolution is possible, a valid resolved object is produced at '*resolved*'.
/// If resolution is not possible, but no error occurs, '*resolved' is set to NULL
///
/// @return true if no error occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_set_t>, ffi.Pointer<realm_t>, ffi.Pointer<ffi.Pointer<realm_set_t>>)>(symbol: 'realm_set_resolve_in')
external bool realm_set_resolve_in(
  ffi.Pointer<realm_set_t> list,
  ffi.Pointer<realm_t> target_realm,
  ffi.Pointer<ffi.Pointer<realm_set_t>> resolved,
);

/// Get the size of a set, in number of unique elements.
///
/// This function may fail if the object owning the set has been deleted.
///
/// @param out_size Where to put the set size. May be NULL.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_set_t>, ffi.Pointer<ffi.Size>)>(symbol: 'realm_set_size')
external bool realm_set_size(
  ffi.Pointer<realm_set_t> arg0,
  ffi.Pointer<ffi.Size> out_size,
);

/// Convert a set to results.
///
/// @return A non-null pointer if no exception occurred.
@ffi.Native<ffi.Pointer<realm_results_t> Function(ffi.Pointer<realm_set_t>)>(symbol: 'realm_set_to_results')
external ffi.Pointer<realm_results_t> realm_set_to_results(
  ffi.Pointer<realm_set_t> arg0,
);

/// Set the value for a property.
///
/// @param new_value The new value for the property.
/// @param is_default True if this property is being set as part of setting the
/// default values for a new object. This has no effect in
/// non-sync'ed realms.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_object_t>, realm_property_key_t, realm_value_t, ffi.Bool)>(symbol: 'realm_set_value')
external bool realm_set_value(
  ffi.Pointer<realm_object_t> arg0,
  int arg1,
  realm_value_t new_value,
  bool is_default,
);

/// Set the values for several properties.
///
/// This is provided as an alternative to calling `realm_get_value()` multiple
/// times in a row, which is particularly useful for language runtimes where
/// crossing the native bridge is comparatively expensive. In addition, it
/// eliminates some parameter validation that would otherwise be repeated for
/// each call.
///
/// Example use cases:
///
/// - Initializing a new object with default values.
/// - Deserializing some in-memory structure into a realm object.
///
/// This operation is "atomic"; if an exception occurs due to invalid input (such
/// as type mismatch, nullability mismatch, etc.), the object will remain
/// unmodified.
///
/// @param num_values The number of elements in @a properties and @a values.
/// @param properties The keys of the properties to set. May not be NULL.
/// @param values The values to assign to the properties. May not be NULL.
/// @param is_default True if the properties are being set as part of setting
/// default values for a new object. This has no effect in
/// non-sync'ed realms.
/// @return True if no exception occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_object_t>, ffi.Size, ffi.Pointer<realm_property_key_t>, ffi.Pointer<realm_value_t>, ffi.Bool)>(
    symbol: 'realm_set_values')
external bool realm_set_values(
  ffi.Pointer<realm_object_t> arg0,
  int num_values,
  ffi.Pointer<realm_property_key_t> properties,
  ffi.Pointer<realm_value_t> values,
  bool is_default,
);

@ffi.Native<ffi.Pointer<realm_sync_client_config_t> Function()>(symbol: 'realm_sync_client_config_new')
external ffi.Pointer<realm_sync_client_config_t> realm_sync_client_config_new();

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_client_config_t>, ffi.Pointer<ffi.Char>)>(symbol: 'realm_sync_client_config_set_base_file_path')
external void realm_sync_client_config_set_base_file_path(
  ffi.Pointer<realm_sync_client_config_t> arg0,
  ffi.Pointer<ffi.Char> arg1,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_client_config_t>, ffi.Uint64)>(symbol: 'realm_sync_client_config_set_connect_timeout')
external void realm_sync_client_config_set_connect_timeout(
  ffi.Pointer<realm_sync_client_config_t> arg0,
  int arg1,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_client_config_t>, ffi.Uint64)>(symbol: 'realm_sync_client_config_set_connection_linger_time')
external void realm_sync_client_config_set_connection_linger_time(
  ffi.Pointer<realm_sync_client_config_t> arg0,
  int arg1,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<realm_sync_client_config_t>,
        realm_on_object_store_thread_callback_t,
        realm_on_object_store_thread_callback_t,
        realm_on_object_store_error_callback_t,
        ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_sync_client_config_set_default_binding_thread_observer')
external void realm_sync_client_config_set_default_binding_thread_observer(
  ffi.Pointer<realm_sync_client_config_t> config,
  realm_on_object_store_thread_callback_t on_thread_create,
  realm_on_object_store_thread_callback_t on_thread_destroy,
  realm_on_object_store_error_callback_t on_error,
  ffi.Pointer<ffi.Void> user_data,
  realm_free_userdata_func_t free_userdata,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_client_config_t>, ffi.Uint64)>(symbol: 'realm_sync_client_config_set_fast_reconnect_limit')
external void realm_sync_client_config_set_fast_reconnect_limit(
  ffi.Pointer<realm_sync_client_config_t> arg0,
  int arg1,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_client_config_t>, ffi.Pointer<ffi.Uint8>)>(symbol: 'realm_sync_client_config_set_metadata_encryption_key')
external void realm_sync_client_config_set_metadata_encryption_key(
  ffi.Pointer<realm_sync_client_config_t> arg0,
  ffi.Pointer<ffi.Uint8> arg1,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_client_config_t>, ffi.Int32)>(symbol: 'realm_sync_client_config_set_metadata_mode')
external void realm_sync_client_config_set_metadata_mode(
  ffi.Pointer<realm_sync_client_config_t> arg0,
  int arg1,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_client_config_t>, ffi.Bool)>(symbol: 'realm_sync_client_config_set_multiplex_sessions')
external void realm_sync_client_config_set_multiplex_sessions(
  ffi.Pointer<realm_sync_client_config_t> arg0,
  bool arg1,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_client_config_t>, ffi.Uint64)>(symbol: 'realm_sync_client_config_set_ping_keepalive_period')
external void realm_sync_client_config_set_ping_keepalive_period(
  ffi.Pointer<realm_sync_client_config_t> arg0,
  int arg1,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_client_config_t>, ffi.Uint64)>(symbol: 'realm_sync_client_config_set_pong_keepalive_timeout')
external void realm_sync_client_config_set_pong_keepalive_timeout(
  ffi.Pointer<realm_sync_client_config_t> arg0,
  int arg1,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_client_config_t>, ffi.Int32)>(symbol: 'realm_sync_client_config_set_reconnect_mode')
external void realm_sync_client_config_set_reconnect_mode(
  ffi.Pointer<realm_sync_client_config_t> arg0,
  int arg1,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_client_config_t>, ffi.Pointer<realm_sync_socket_t>)>(symbol: 'realm_sync_client_config_set_sync_socket')
external void realm_sync_client_config_set_sync_socket(
  ffi.Pointer<realm_sync_client_config_t> arg0,
  ffi.Pointer<realm_sync_socket_t> arg1,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_client_config_t>, ffi.Pointer<ffi.Char>)>(
    symbol: 'realm_sync_client_config_set_user_agent_application_info')
external void realm_sync_client_config_set_user_agent_application_info(
  ffi.Pointer<realm_sync_client_config_t> arg0,
  ffi.Pointer<ffi.Char> arg1,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_client_config_t>, ffi.Pointer<ffi.Char>)>(symbol: 'realm_sync_client_config_set_user_agent_binding_info')
external void realm_sync_client_config_set_user_agent_binding_info(
  ffi.Pointer<realm_sync_client_config_t> arg0,
  ffi.Pointer<ffi.Char> arg1,
);

@ffi.Native<ffi.Pointer<realm_sync_config_t> Function(ffi.Pointer<realm_user_t>, ffi.Pointer<ffi.Char>)>(symbol: 'realm_sync_config_new')
external ffi.Pointer<realm_sync_config_t> realm_sync_config_new(
  ffi.Pointer<realm_user_t> arg0,
  ffi.Pointer<ffi.Char> partition_value,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_config_t>, realm_sync_after_client_reset_func_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(
    symbol: 'realm_sync_config_set_after_client_reset_handler')
external void realm_sync_config_set_after_client_reset_handler(
  ffi.Pointer<realm_sync_config_t> arg0,
  realm_sync_after_client_reset_func_t arg1,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// DEPRECATED - Will be removed in a future release
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_config_t>, ffi.Pointer<ffi.Char>)>(symbol: 'realm_sync_config_set_authorization_header_name')
external void realm_sync_config_set_authorization_header_name(
  ffi.Pointer<realm_sync_config_t> arg0,
  ffi.Pointer<ffi.Char> arg1,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_config_t>, realm_sync_before_client_reset_func_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(
    symbol: 'realm_sync_config_set_before_client_reset_handler')
external void realm_sync_config_set_before_client_reset_handler(
  ffi.Pointer<realm_sync_config_t> arg0,
  realm_sync_before_client_reset_func_t arg1,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_config_t>, ffi.Bool)>(symbol: 'realm_sync_config_set_cancel_waits_on_nonfatal_error')
external void realm_sync_config_set_cancel_waits_on_nonfatal_error(
  ffi.Pointer<realm_sync_config_t> arg0,
  bool arg1,
);

/// DEPRECATED - Will be removed in a future release
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_config_t>, ffi.Bool)>(symbol: 'realm_sync_config_set_client_validate_ssl')
external void realm_sync_config_set_client_validate_ssl(
  ffi.Pointer<realm_sync_config_t> arg0,
  bool arg1,
);

/// DEPRECATED - Will be removed in a future release
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_config_t>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>(
    symbol: 'realm_sync_config_set_custom_http_header')
external void realm_sync_config_set_custom_http_header(
  ffi.Pointer<realm_sync_config_t> arg0,
  ffi.Pointer<ffi.Char> name,
  ffi.Pointer<ffi.Char> value,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_config_t>, realm_sync_error_handler_func_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(
    symbol: 'realm_sync_config_set_error_handler')
external void realm_sync_config_set_error_handler(
  ffi.Pointer<realm_sync_config_t> arg0,
  realm_sync_error_handler_func_t arg1,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<realm_sync_config_t>, realm_async_open_task_init_subscription_func_t, ffi.Bool, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_sync_config_set_initial_subscription_handler')
external void realm_sync_config_set_initial_subscription_handler(
  ffi.Pointer<realm_sync_config_t> arg0,
  realm_async_open_task_init_subscription_func_t arg1,
  bool rerun_on_open,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_config_t>, ffi.Pointer<ffi.Char>)>(symbol: 'realm_sync_config_set_recovery_directory_path')
external void realm_sync_config_set_recovery_directory_path(
  ffi.Pointer<realm_sync_config_t> arg0,
  ffi.Pointer<ffi.Char> arg1,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_config_t>, ffi.Int32)>(symbol: 'realm_sync_config_set_resync_mode')
external void realm_sync_config_set_resync_mode(
  ffi.Pointer<realm_sync_config_t> arg0,
  int arg1,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_config_t>, ffi.Int32)>(symbol: 'realm_sync_config_set_session_stop_policy')
external void realm_sync_config_set_session_stop_policy(
  ffi.Pointer<realm_sync_config_t> arg0,
  int arg1,
);

/// DEPRECATED - Will be removed in a future release
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_config_t>, ffi.Pointer<ffi.Char>)>(symbol: 'realm_sync_config_set_ssl_trust_certificate_path')
external void realm_sync_config_set_ssl_trust_certificate_path(
  ffi.Pointer<realm_sync_config_t> arg0,
  ffi.Pointer<ffi.Char> arg1,
);

/// DEPRECATED - Will be removed in a future release
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_config_t>, realm_sync_ssl_verify_func_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(
    symbol: 'realm_sync_config_set_ssl_verify_callback')
external void realm_sync_config_set_ssl_verify_callback(
  ffi.Pointer<realm_sync_config_t> arg0,
  realm_sync_ssl_verify_func_t arg1,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Find subscription by name passed as parameter
/// @return a pointer to the subscription or nullptr if not found
@ffi.Native<ffi.Pointer<realm_flx_sync_subscription_t> Function(ffi.Pointer<realm_flx_sync_subscription_set_t>, ffi.Pointer<ffi.Char>)>(
    symbol: 'realm_sync_find_subscription_by_name')
external ffi.Pointer<realm_flx_sync_subscription_t> realm_sync_find_subscription_by_name(
  ffi.Pointer<realm_flx_sync_subscription_set_t> arg0,
  ffi.Pointer<ffi.Char> name,
);

/// Find subscription associated to the query passed as parameter
/// @return a pointer to the subscription or nullptr if not found
@ffi.Native<ffi.Pointer<realm_flx_sync_subscription_t> Function(ffi.Pointer<realm_flx_sync_subscription_set_t>, ffi.Pointer<realm_query_t>)>(
    symbol: 'realm_sync_find_subscription_by_query')
external ffi.Pointer<realm_flx_sync_subscription_t> realm_sync_find_subscription_by_query(
  ffi.Pointer<realm_flx_sync_subscription_set_t> arg0,
  ffi.Pointer<realm_query_t> arg1,
);

/// Find subscription associated to the results set  passed as parameter
/// @return a pointer to the subscription or nullptr if not found
@ffi.Native<ffi.Pointer<realm_flx_sync_subscription_t> Function(ffi.Pointer<realm_flx_sync_subscription_set_t>, ffi.Pointer<realm_results_t>)>(
    symbol: 'realm_sync_find_subscription_by_results')
external ffi.Pointer<realm_flx_sync_subscription_t> realm_sync_find_subscription_by_results(
  ffi.Pointer<realm_flx_sync_subscription_set_t> arg0,
  ffi.Pointer<realm_results_t> arg1,
);

/// Get active subscription set
/// @return a non null subscription set pointer if such it exists.
@ffi.Native<ffi.Pointer<realm_flx_sync_subscription_set_t> Function(ffi.Pointer<realm_t>)>(symbol: 'realm_sync_get_active_subscription_set')
external ffi.Pointer<realm_flx_sync_subscription_set_t> realm_sync_get_active_subscription_set(
  ffi.Pointer<realm_t> arg0,
);

/// Get latest subscription set
/// @return a non null subscription set pointer if such it exists.
@ffi.Native<ffi.Pointer<realm_flx_sync_subscription_set_t> Function(ffi.Pointer<realm_t>)>(symbol: 'realm_sync_get_latest_subscription_set')
external ffi.Pointer<realm_flx_sync_subscription_set_t> realm_sync_get_latest_subscription_set(
  ffi.Pointer<realm_t> arg0,
);

/// In case manual reset is needed, run this function in order to reset sync client files.
/// The sync_path is going to passed into realm_sync_error_handler_func_t, if manual reset is needed.
/// This function is supposed to be called inside realm_sync_error_handler_func_t callback, if sync client reset is
/// needed
/// @param realm_app ptr to realm app.
/// @param sync_path path where the sync files are.
/// @param did_run ptr to bool, which will be set to true if operation was successful
/// @return true if operation was successful
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_app_t>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Bool>)>(symbol: 'realm_sync_immediately_run_file_actions')
external bool realm_sync_immediately_run_file_actions(
  ffi.Pointer<realm_app_t> realm_app,
  ffi.Pointer<ffi.Char> sync_path,
  ffi.Pointer<ffi.Bool> did_run,
);

/// Convert a subscription into a mutable one in order to alter the subscription itself
/// @return a pointer to a mutable subscription
@ffi.Native<ffi.Pointer<realm_flx_sync_mutable_subscription_set_t> Function(ffi.Pointer<realm_flx_sync_subscription_set_t>)>(
    symbol: 'realm_sync_make_subscription_set_mutable')
external ffi.Pointer<realm_flx_sync_mutable_subscription_set_t> realm_sync_make_subscription_set_mutable(
  ffi.Pointer<realm_flx_sync_subscription_set_t> arg0,
);

/// Register a handler in order to be notified when subscription set is equal to the one passed as parameter
/// This is an asynchronous operation.
/// @return true/false if the handler was registered correctly
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_flx_sync_subscription_set_t>, ffi.Int32, realm_sync_on_subscription_state_changed_t, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_sync_on_subscription_set_state_change_async')
external bool realm_sync_on_subscription_set_state_change_async(
  ffi.Pointer<realm_flx_sync_subscription_set_t> subscription_set,
  int notify_when,
  realm_sync_on_subscription_state_changed_t arg2,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Wait until subscripton set state is equal to the state passed as parameter.
/// This is a blocking operation.
/// @return the current subscription state
@ffi.Native<ffi.Int32 Function(ffi.Pointer<realm_flx_sync_subscription_set_t>, ffi.Int32)>(symbol: 'realm_sync_on_subscription_set_state_change_wait')
external int realm_sync_on_subscription_set_state_change_wait(
  ffi.Pointer<realm_flx_sync_subscription_set_t> arg0,
  int arg1,
);

/// Get the sync session for a specific realm.
///
/// This function will not fail if the realm wasn't open with a sync configuration in place,
/// but just return NULL;
///
/// @return A non-null pointer if a session exists.
@ffi.Native<ffi.Pointer<realm_sync_session_t> Function(ffi.Pointer<realm_t>)>(symbol: 'realm_sync_session_get')
external ffi.Pointer<realm_sync_session_t> realm_sync_session_get(
  ffi.Pointer<realm_t> arg0,
);

/// Fetch connection state for the session passed as parameter
/// @param session ptr to the sync session to retrieve the state for
/// @return realm_sync_connection_state_e value
@ffi.Native<ffi.Int32 Function(ffi.Pointer<realm_sync_session_t>)>(symbol: 'realm_sync_session_get_connection_state')
external int realm_sync_session_get_connection_state(
  ffi.Pointer<realm_sync_session_t> session,
);

/// Get the filesystem path of the realm file backing this session.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<realm_sync_session_t>)>(symbol: 'realm_sync_session_get_file_path')
external ffi.Pointer<ffi.Char> realm_sync_session_get_file_path(
  ffi.Pointer<realm_sync_session_t> arg0,
);

/// Fetch partition value for the session passed as parameter
/// @param session ptr to the sync session to retrieve the partition value for
/// @return a string containing the partition value
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<realm_sync_session_t>)>(symbol: 'realm_sync_session_get_partition_value')
external ffi.Pointer<ffi.Char> realm_sync_session_get_partition_value(
  ffi.Pointer<realm_sync_session_t> session,
);

/// Fetch state for the session passed as parameter
/// @param session ptr to the sync session to retrieve the state for
/// @return realm_sync_session_state_e value
@ffi.Native<ffi.Int32 Function(ffi.Pointer<realm_sync_session_t>)>(symbol: 'realm_sync_session_get_state')
external int realm_sync_session_get_state(
  ffi.Pointer<realm_sync_session_t> session,
);

/// Fetch user for the session passed as parameter
/// @param session ptr to the sync session to retrieve the user for
/// @return ptr to realm_user_t
@ffi.Native<ffi.Pointer<realm_user_t> Function(ffi.Pointer<realm_sync_session_t>)>(symbol: 'realm_sync_session_get_user')
external ffi.Pointer<realm_user_t> realm_sync_session_get_user(
  ffi.Pointer<realm_sync_session_t> session,
);

/// Wrapper for SyncSession::OnlyForTesting::handle_error. This routine should be used only for testing.
/// @param session ptr to a valid sync session
/// @param error_code realm_errno_e representing the error to simulate
/// @param error_str error message to be included with Status
/// @param is_fatal boolean to signal if the error is fatal or not
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_session_t>, ffi.Int32, ffi.Pointer<ffi.Char>, ffi.Bool)>(
    symbol: 'realm_sync_session_handle_error_for_testing')
external void realm_sync_session_handle_error_for_testing(
  ffi.Pointer<realm_sync_session_t> session,
  int error_code,
  ffi.Pointer<ffi.Char> error_str,
  bool is_fatal,
);

/// Ask the session to pause synchronization.
///
/// No-op if the session is already inactive.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_session_t>)>(symbol: 'realm_sync_session_pause')
external void realm_sync_session_pause(
  ffi.Pointer<realm_sync_session_t> arg0,
);

/// Register a callback that will be invoked every time the session's connection state changes.
///
/// @return a notification token object. Dispose it to stop receiving notifications.
@ffi.Native<
    ffi.Pointer<realm_sync_session_connection_state_notification_token_t> Function(
        ffi.Pointer<realm_sync_session_t>,
        realm_sync_connection_state_changed_func_t,
        ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_sync_session_register_connection_state_change_callback')
external ffi.Pointer<realm_sync_session_connection_state_notification_token_t> realm_sync_session_register_connection_state_change_callback(
  ffi.Pointer<realm_sync_session_t> arg0,
  realm_sync_connection_state_changed_func_t arg1,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Register a callback that will be invoked every time the session reports progress.
///
/// @param is_streaming If true, then the notifier will be called forever, and will
/// always contain the most up-to-date number of downloadable or uploadable bytes.
/// Otherwise, the number of downloaded or uploaded bytes will always be reported
/// relative to the number of downloadable or uploadable bytes at the point in time
/// when the notifier was registered.
/// @return a notification token object. Dispose it to stop receiving notifications.
@ffi.Native<
    ffi.Pointer<realm_sync_session_connection_state_notification_token_t> Function(ffi.Pointer<realm_sync_session_t>, realm_sync_progress_func_t, ffi.Int32,
        ffi.Bool, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(symbol: 'realm_sync_session_register_progress_notifier')
external ffi.Pointer<realm_sync_session_connection_state_notification_token_t> realm_sync_session_register_progress_notifier(
  ffi.Pointer<realm_sync_session_t> arg0,
  realm_sync_progress_func_t arg1,
  int arg2,
  bool is_streaming,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Ask the session to resume synchronization.
///
/// No-op if the session is already active.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_session_t>)>(symbol: 'realm_sync_session_resume')
external void realm_sync_session_resume(
  ffi.Pointer<realm_sync_session_t> arg0,
);

/// Register a callback that will be invoked when all pending downloads have completed.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_session_t>, realm_sync_wait_for_completion_func_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(
    symbol: 'realm_sync_session_wait_for_download_completion')
external void realm_sync_session_wait_for_download_completion(
  ffi.Pointer<realm_sync_session_t> arg0,
  realm_sync_wait_for_completion_func_t arg1,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Register a callback that will be invoked when all pending uploads have completed.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_session_t>, realm_sync_wait_for_completion_func_t, ffi.Pointer<ffi.Void>, realm_free_userdata_func_t)>(
    symbol: 'realm_sync_session_wait_for_upload_completion')
external void realm_sync_session_wait_for_upload_completion(
  ffi.Pointer<realm_sync_session_t> arg0,
  realm_sync_wait_for_completion_func_t arg1,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Creates a new sync socket instance for the Sync Client that handles the operations for a custom
/// websocket and event loop implementation.
/// @param userdata CAPI implementation specific pointer containing custom context data that is provided to
/// each of the provided functions.
/// @param userdata_free function that will be called when the sync socket is destroyed to delete userdata. This
/// is required if userdata is not null.
/// @param post_func function that will be called to post a callback handler onto the event loop - use the
/// realm_sync_socket_post_complete() function when the callback handler is scheduled to run.
/// @param create_timer_func function that will be called to create a new timer resource with the callback
/// handler that will be run when the timer expires or an erorr occurs - use the
/// realm_sync_socket_timer_canceled() function if the timer is canceled or the
/// realm_sync_socket_timer_complete() function if the timer expires or an error occurs.
/// @param cancel_timer_func function that will be called when the timer has been canceled by the sync client.
/// @param free_timer_func function that will be called when the timer resource has been destroyed by the sync client.
/// @param websocket_connect_func function that will be called when the sync client creates a websocket.
/// @param websocket_write_func function that will be called when the sync client sends data over the websocket.
/// @param websocket_free_func function that will be called when the sync client closes the websocket conneciton.
/// @return a realm_sync_socket_t pointer suitable for passing to realm_sync_client_config_set_sync_socket()
@ffi.Native<
    ffi.Pointer<realm_sync_socket_t> Function(
        ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t,
        realm_sync_socket_post_func_t,
        realm_sync_socket_create_timer_func_t,
        realm_sync_socket_timer_canceled_func_t,
        realm_sync_socket_timer_free_func_t,
        realm_sync_socket_connect_func_t,
        realm_sync_socket_websocket_async_write_func_t,
        realm_sync_socket_websocket_free_func_t)>(symbol: 'realm_sync_socket_new')
external ffi.Pointer<realm_sync_socket_t> realm_sync_socket_new(
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
  realm_sync_socket_post_func_t post_func,
  realm_sync_socket_create_timer_func_t create_timer_func,
  realm_sync_socket_timer_canceled_func_t cancel_timer_func,
  realm_sync_socket_timer_free_func_t free_timer_func,
  realm_sync_socket_connect_func_t websocket_connect_func,
  realm_sync_socket_websocket_async_write_func_t websocket_write_func,
  realm_sync_socket_websocket_free_func_t websocket_free_func,
);

/// To be called to execute the callback function provided to the post_func when the event loop executes
/// that post'ed operation. The post_handler resource will automatically be destroyed during this
/// operation.
/// @param post_handler the post callback handler that was originally provided to the post_func
/// @param result the error code for the error that occurred or RLM_ERR_SYNC_SOCKET_SUCCESS if the
/// callback handler should be executed normally.
/// @param reason a string describing details about the error that occurred or empty string if no error.
/// NOTE: This function must be called by the event loop execution thread.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_socket_post_callback_t>, ffi.Int32, ffi.Pointer<ffi.Char>)>(symbol: 'realm_sync_socket_post_complete')
external void realm_sync_socket_post_complete(
  ffi.Pointer<realm_sync_socket_post_callback_t> post_handler,
  int result,
  ffi.Pointer<ffi.Char> reason,
);

/// To be called to execute the callback handler provided to the create_timer_func when the timer has been
/// canceled.
/// @param timer_handler the timer callback handler that was provided when the timer was created.
/// NOTE: This function must be called by the event loop execution thread.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_socket_timer_callback_t>)>(symbol: 'realm_sync_socket_timer_canceled')
external void realm_sync_socket_timer_canceled(
  ffi.Pointer<realm_sync_socket_timer_callback_t> timer_handler,
);

/// To be called to execute the callback handler provided to the create_timer_func when the timer is
/// complete or an error occurs while processing the timer.
/// @param timer_handler the timer callback handler that was provided when the timer was created.
/// @param result the error code for the error that occurred or RLM_ERR_SYNC_SOCKET_SUCCESS if the timer
/// expired normally.
/// @param reason a string describing details about the error that occurred or empty string if no error.
/// NOTE: This function must be called by the event loop execution thread.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_socket_timer_callback_t>, ffi.Int32, ffi.Pointer<ffi.Char>)>(symbol: 'realm_sync_socket_timer_complete')
external void realm_sync_socket_timer_complete(
  ffi.Pointer<realm_sync_socket_timer_callback_t> timer_handler,
  int result,
  ffi.Pointer<ffi.Char> reason,
);

/// To be called when the websocket has been closed, either due to an error or a normal close operation.
/// @param realm_websocket_observer the websocket observer object that was provided to the websocket_connect_func
/// @param was_clean boolean value that indicates whether this is a normal close situation (true), the
/// close code was provided by the server via a close message (true), or if the close code was
/// generated by the local websocket as a result of some other error (false) (e.g. host
/// unreachable, etc.)
/// @param code the websocket close code (per the WebSocket spec) that describes why the websocket was closed.
/// @param reason a string describing details about the error that occurred or empty string if no error.
/// @return bool designates whether the WebSocket object has been destroyed during the execution of this
/// function. The normal return value is True to indicate the WebSocket object is no longer valid. If
/// False is returned, the WebSocket object will be destroyed at some point in the future.
/// NOTE: This function must be called by the event loop execution thread and should not be called
/// after the websocket_free_func has been called to release the websocket resources.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_websocket_observer_t>, ffi.Bool, ffi.Int32, ffi.Pointer<ffi.Char>)>(
    symbol: 'realm_sync_socket_websocket_closed')
external bool realm_sync_socket_websocket_closed(
  ffi.Pointer<realm_websocket_observer_t> realm_websocket_observer,
  bool was_clean,
  int code,
  ffi.Pointer<ffi.Char> reason,
);

/// To be called when the websocket successfully connects to the server.
/// @param realm_websocket_observer the websocket observer object that was provided to the websocket_connect_func
/// @param protocol the value of the Sec-WebSocket-Protocol header in the connect response from the server.
/// NOTE: This function must be called by the event loop execution thread and should not be called
/// after the websocket_free_func has been called to release the websocket resources.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_websocket_observer_t>, ffi.Pointer<ffi.Char>)>(symbol: 'realm_sync_socket_websocket_connected')
external void realm_sync_socket_websocket_connected(
  ffi.Pointer<realm_websocket_observer_t> realm_websocket_observer,
  ffi.Pointer<ffi.Char> protocol,
);

/// To be called when an error occurs - the actual error value will be provided when the websocket_closed
/// function is called. This function informs that the socket object is in an error state and no further
/// TX operations should be performed.
/// @param realm_websocket_observer the websocket observer object that was provided to the websocket_connect_func
/// NOTE: This function must be called by the event loop execution thread and should not be called
/// after the websocket_free_func has been called to release the websocket resources.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_websocket_observer_t>)>(symbol: 'realm_sync_socket_websocket_error')
external void realm_sync_socket_websocket_error(
  ffi.Pointer<realm_websocket_observer_t> realm_websocket_observer,
);

/// To be called to provide the received data to the Sync Client when a write operation has completed.
/// The data buffer can be safely discarded after this function has completed.
/// @param realm_websocket_observer the websocket observer object that was provided to the websocket_connect_func
/// @param data a pointer to the buffer that contains the data received over the websocket
/// @param data_size the number of bytes in the data buffer
/// @return bool designates whether the WebSocket object should continue processing messages. The normal return
/// value is true. False must be returned if the websocket object has been destroyed during execution of
/// the function.
/// NOTE: This function must be called by the event loop execution thread and should not be called
/// after the websocket_free_func has been called to release the websocket resources.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_websocket_observer_t>, ffi.Pointer<ffi.Char>, ffi.Size)>(symbol: 'realm_sync_socket_websocket_message')
external bool realm_sync_socket_websocket_message(
  ffi.Pointer<realm_websocket_observer_t> realm_websocket_observer,
  ffi.Pointer<ffi.Char> data,
  int data_size,
);

/// To be called to execute the callback function provided to the websocket_write_func when the write
/// operation is complete. The write_handler resource will automatically be destroyed during this
/// operation.
/// @param write_handler the write callback handler that was originally provided to the websocket_write_func
/// @param result the error code for the error that occurred or RLM_ERR_SYNC_SOCKET_SUCCESS if write completed
/// successfully
/// @param reason a string describing details about the error that occurred or empty string if no error.
/// NOTE: This function must be called by the event loop execution thread.
@ffi.Native<ffi.Void Function(ffi.Pointer<realm_sync_socket_write_callback_t>, ffi.Int32, ffi.Pointer<ffi.Char>)>(symbol: 'realm_sync_socket_write_complete')
external void realm_sync_socket_write_complete(
  ffi.Pointer<realm_sync_socket_write_callback_t> write_handler,
  int result,
  ffi.Pointer<ffi.Char> reason,
);

/// Access the subscription at index.
/// @return the subscription or nullptr if the index is not valid
@ffi.Native<ffi.Pointer<realm_flx_sync_subscription_t> Function(ffi.Pointer<realm_flx_sync_subscription_set_t>, ffi.Size)>(symbol: 'realm_sync_subscription_at')
external ffi.Pointer<realm_flx_sync_subscription_t> realm_sync_subscription_at(
  ffi.Pointer<realm_flx_sync_subscription_set_t> arg0,
  int index,
);

/// Fetch the timestamp in which the subscription was created for the subscription passed as argument.
/// @return realm_timestamp_t representing the timestamp in which the subscription for created.
@ffi.Native<realm_timestamp_t Function(ffi.Pointer<realm_flx_sync_subscription_t>)>(symbol: 'realm_sync_subscription_created_at')
external realm_timestamp_t realm_sync_subscription_created_at(
  ffi.Pointer<realm_flx_sync_subscription_t> subscription,
);

/// Fetch subscription id for the subscription passed as argument.
/// @return realm_object_id_t for the subscription passed as argument
@ffi.Native<realm_object_id_t Function(ffi.Pointer<realm_flx_sync_subscription_t>)>(symbol: 'realm_sync_subscription_id')
external realm_object_id_t realm_sync_subscription_id(
  ffi.Pointer<realm_flx_sync_subscription_t> subscription,
);

/// Fetch subscription name for the subscription passed as argument.
/// @return realm_string_t which contains the name of the subscription.
@ffi.Native<realm_string_t Function(ffi.Pointer<realm_flx_sync_subscription_t>)>(symbol: 'realm_sync_subscription_name')
external realm_string_t realm_sync_subscription_name(
  ffi.Pointer<realm_flx_sync_subscription_t> subscription,
);

/// Fetch object class name for the subscription passed as argument.
/// @return a realm_string_t which contains the class name of the subscription.
@ffi.Native<realm_string_t Function(ffi.Pointer<realm_flx_sync_subscription_t>)>(symbol: 'realm_sync_subscription_object_class_name')
external realm_string_t realm_sync_subscription_object_class_name(
  ffi.Pointer<realm_flx_sync_subscription_t> subscription,
);

/// Fetch the query string associated with the subscription passed as argument.
/// @return realm_string_t which contains the query associated with the subscription.
@ffi.Native<realm_string_t Function(ffi.Pointer<realm_flx_sync_subscription_t>)>(symbol: 'realm_sync_subscription_query_string')
external realm_string_t realm_sync_subscription_query_string(
  ffi.Pointer<realm_flx_sync_subscription_t> subscription,
);

/// Clear the subscription set passed as parameter
/// @return true/false if operation was successful
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_flx_sync_mutable_subscription_set_t>)>(symbol: 'realm_sync_subscription_set_clear')
external bool realm_sync_subscription_set_clear(
  ffi.Pointer<realm_flx_sync_mutable_subscription_set_t> arg0,
);

/// Commit the subscription_set passed as parameter (in order that all the changes made will take effect)
/// @return pointer to a valid immutable subscription if commit was successful
@ffi.Native<ffi.Pointer<realm_flx_sync_subscription_set_t> Function(ffi.Pointer<realm_flx_sync_mutable_subscription_set_t>)>(
    symbol: 'realm_sync_subscription_set_commit')
external ffi.Pointer<realm_flx_sync_subscription_set_t> realm_sync_subscription_set_commit(
  ffi.Pointer<realm_flx_sync_mutable_subscription_set_t> arg0,
);

/// Remove all subscriptions for a given class type. If operation completes successfully set the bool out param.
/// @return true if no error occurred, false otherwise (use realm_get_last_error for fetching the error).
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_flx_sync_mutable_subscription_set_t>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Bool>)>(
    symbol: 'realm_sync_subscription_set_erase_by_class_name')
external bool realm_sync_subscription_set_erase_by_class_name(
  ffi.Pointer<realm_flx_sync_mutable_subscription_set_t> arg0,
  ffi.Pointer<ffi.Char> arg1,
  ffi.Pointer<ffi.Bool> erased,
);

/// Erase from subscription set by id. If operation completes successfully set the bool out param.
/// @return true if no error occurred, false otherwise (use realm_get_last_error for fetching the error).
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_flx_sync_mutable_subscription_set_t>, ffi.Pointer<realm_object_id_t>, ffi.Pointer<ffi.Bool>)>(
    symbol: 'realm_sync_subscription_set_erase_by_id')
external bool realm_sync_subscription_set_erase_by_id(
  ffi.Pointer<realm_flx_sync_mutable_subscription_set_t> arg0,
  ffi.Pointer<realm_object_id_t> arg1,
  ffi.Pointer<ffi.Bool> erased,
);

/// Erase from subscription set by name. If operation completes successfully set the bool out param.
/// @return true if no error occurred, false otherwise (use realm_get_last_error for fetching the error)
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_flx_sync_mutable_subscription_set_t>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Bool>)>(
    symbol: 'realm_sync_subscription_set_erase_by_name')
external bool realm_sync_subscription_set_erase_by_name(
  ffi.Pointer<realm_flx_sync_mutable_subscription_set_t> arg0,
  ffi.Pointer<ffi.Char> arg1,
  ffi.Pointer<ffi.Bool> erased,
);

/// Erase from subscription set by query. If operation completes successfully set the bool out param.
/// @return true if no error occurred, false otherwise (use realm_get_last_error for fetching the error)
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_flx_sync_mutable_subscription_set_t>, ffi.Pointer<realm_query_t>, ffi.Pointer<ffi.Bool>)>(
    symbol: 'realm_sync_subscription_set_erase_by_query')
external bool realm_sync_subscription_set_erase_by_query(
  ffi.Pointer<realm_flx_sync_mutable_subscription_set_t> arg0,
  ffi.Pointer<realm_query_t> arg1,
  ffi.Pointer<ffi.Bool> erased,
);

/// Erase from subscription set by results. If operation completes successfully set the bool out param.
/// @return true if no error occurred, false otherwise (use realm_get_last_error for fetching the error)
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_flx_sync_mutable_subscription_set_t>, ffi.Pointer<realm_results_t>, ffi.Pointer<ffi.Bool>)>(
    symbol: 'realm_sync_subscription_set_erase_by_results')
external bool realm_sync_subscription_set_erase_by_results(
  ffi.Pointer<realm_flx_sync_mutable_subscription_set_t> arg0,
  ffi.Pointer<realm_results_t> arg1,
  ffi.Pointer<ffi.Bool> erased,
);

/// Query subscription set error string
/// @return error string for the subscription passed as parameter
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<realm_flx_sync_subscription_set_t>)>(symbol: 'realm_sync_subscription_set_error_str')
external ffi.Pointer<ffi.Char> realm_sync_subscription_set_error_str(
  ffi.Pointer<realm_flx_sync_subscription_set_t> arg0,
);

/// Insert ot update a query for the subscription set passed as parameter, if successful the index where the query
/// was inserted or updated is returned along with the info whether a new query was inserted or not. It is possible to
/// specify a name for the query inserted (optional).
/// @return true/false if operation was successful
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_flx_sync_mutable_subscription_set_t>, ffi.Pointer<realm_query_t>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Size>,
        ffi.Pointer<ffi.Bool>)>(symbol: 'realm_sync_subscription_set_insert_or_assign_query')
external bool realm_sync_subscription_set_insert_or_assign_query(
  ffi.Pointer<realm_flx_sync_mutable_subscription_set_t> arg0,
  ffi.Pointer<realm_query_t> arg1,
  ffi.Pointer<ffi.Char> name,
  ffi.Pointer<ffi.Size> out_index,
  ffi.Pointer<ffi.Bool> out_inserted,
);

/// Insert ot update the query contained inside a result object for the subscription set passed as parameter, if
/// successful the index where the query was inserted or updated is returned along with the info whether a new query
/// was inserted or not. It is possible to specify a name for the query inserted (optional).
/// @return true/false if operation was successful
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_flx_sync_mutable_subscription_set_t>, ffi.Pointer<realm_results_t>, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Size>,
        ffi.Pointer<ffi.Bool>)>(symbol: 'realm_sync_subscription_set_insert_or_assign_results')
external bool realm_sync_subscription_set_insert_or_assign_results(
  ffi.Pointer<realm_flx_sync_mutable_subscription_set_t> arg0,
  ffi.Pointer<realm_results_t> arg1,
  ffi.Pointer<ffi.Char> name,
  ffi.Pointer<ffi.Size> out_index,
  ffi.Pointer<ffi.Bool> out_inserted,
);

/// Refresh subscription
/// @return true/false if the operation was successful or not
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_flx_sync_subscription_set_t>)>(symbol: 'realm_sync_subscription_set_refresh')
external bool realm_sync_subscription_set_refresh(
  ffi.Pointer<realm_flx_sync_subscription_set_t> arg0,
);

/// Retrieve the number of subscriptions for the subscription set passed as parameter
/// @return the number of subscriptions
@ffi.Native<ffi.Size Function(ffi.Pointer<realm_flx_sync_subscription_set_t>)>(symbol: 'realm_sync_subscription_set_size')
external int realm_sync_subscription_set_size(
  ffi.Pointer<realm_flx_sync_subscription_set_t> arg0,
);

/// Fetch current state for the subscription set passed as parameter
/// @return the current state of the subscription_set
@ffi.Native<ffi.Int32 Function(ffi.Pointer<realm_flx_sync_subscription_set_t>)>(symbol: 'realm_sync_subscription_set_state')
external int realm_sync_subscription_set_state(
  ffi.Pointer<realm_flx_sync_subscription_set_t> arg0,
);

/// Retrieve version for the subscription set passed as parameter
/// @return subscription set version if the poiter to the subscription is valid
@ffi.Native<ffi.Int64 Function(ffi.Pointer<realm_flx_sync_subscription_set_t>)>(symbol: 'realm_sync_subscription_set_version')
external int realm_sync_subscription_set_version(
  ffi.Pointer<realm_flx_sync_subscription_set_t> arg0,
);

/// Fetch the timestamp in which the subscription was updated for the subscription passed as argument.
/// @return realm_timestamp_t representing the timestamp in which the subscription was updated.
@ffi.Native<realm_timestamp_t Function(ffi.Pointer<realm_flx_sync_subscription_t>)>(symbol: 'realm_sync_subscription_updated_at')
external realm_timestamp_t realm_sync_subscription_updated_at(
  ffi.Pointer<realm_flx_sync_subscription_t> subscription,
);

/// @return a notification token object. Dispose it to stop receiving notifications.
@ffi.Native<
    ffi.Pointer<realm_sync_user_subscription_token_t> Function(ffi.Pointer<realm_user_t>, realm_sync_on_user_state_changed_t, ffi.Pointer<ffi.Void>,
        realm_free_userdata_func_t)>(symbol: 'realm_sync_user_on_state_change_register_callback')
external ffi.Pointer<realm_sync_user_subscription_token_t> realm_sync_user_on_state_change_register_callback(
  ffi.Pointer<realm_user_t> arg0,
  realm_sync_on_user_state_changed_t arg1,
  ffi.Pointer<ffi.Void> userdata,
  realm_free_userdata_func_t userdata_free,
);

/// Update the schema of an open realm.
///
/// This is equivalent to calling `realm_update_schema_advanced(realm, schema, 0,
/// NULL, NULL, NULL, NULL, false)`.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_t>, ffi.Pointer<realm_schema_t>)>(symbol: 'realm_update_schema')
external bool realm_update_schema(
  ffi.Pointer<realm_t> realm,
  ffi.Pointer<realm_schema_t> schema,
);

/// Update the schema of an open realm, with options to customize certain steps
/// of the process.
///
/// @param realm The realm for which the schema should be updated.
/// @param schema The new schema for the realm. If the schema is the same the
/// existing schema, this function does nothing.
/// @param version The version of the new schema.
/// @param migration_func Callback to perform the migration. Has no effect if the
/// Realm is opened with `RLM_SCHEMA_MODE_ADDITIVE`.
/// @param migration_func_userdata Userdata pointer to pass to `migration_func`.
/// @param data_init_func Callback to perform initialization of the data in the
/// Realm if it is opened for the first time (i.e., it has
/// no previous schema version).
/// @param data_init_func_userdata Userdata pointer to pass to `data_init_func`.
/// @param is_in_transaction Pass true if the realm is already in a write
/// transaction. Otherwise, if the migration requires a
/// write transaction, this function will perform the
/// migration in its own write transaction.
@ffi.Native<
    ffi.Bool Function(ffi.Pointer<realm_t>, ffi.Pointer<realm_schema_t>, ffi.Uint64, realm_migration_func_t, ffi.Pointer<ffi.Void>,
        realm_data_initialization_func_t, ffi.Pointer<ffi.Void>, ffi.Bool)>(symbol: 'realm_update_schema_advanced')
external bool realm_update_schema_advanced(
  ffi.Pointer<realm_t> realm,
  ffi.Pointer<realm_schema_t> schema,
  int version,
  realm_migration_func_t migration_func,
  ffi.Pointer<ffi.Void> migration_func_userdata,
  realm_data_initialization_func_t data_init_func,
  ffi.Pointer<ffi.Void> data_init_func_userdata,
  bool is_in_transaction,
);

/// Return the access token associated with the user.
/// @return a string that rapresents the access token
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<realm_user_t>)>(symbol: 'realm_user_get_access_token')
external ffi.Pointer<ffi.Char> realm_user_get_access_token(
  ffi.Pointer<realm_user_t> arg0,
);

/// Get the list of identities of this @a user.
///
/// @param out_identities A pointer to an array of `realm_user_identity_t`, which
/// will be populated with the list of identities of this user.
/// Array may be NULL, in this case no data will be copied and `out_n` set if not NULL.
/// @param capacity The maximum number of elements `out_identities` can hold.
/// @param out_n The actual number of entries written to `out_identities`. May be NULL.
/// @return true, if no errors occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_user_t>, ffi.Pointer<realm_user_identity_t>, ffi.Size, ffi.Pointer<ffi.Size>)>(
    symbol: 'realm_user_get_all_identities')
external bool realm_user_get_all_identities(
  ffi.Pointer<realm_user_t> user,
  ffi.Pointer<realm_user_identity_t> out_identities,
  int capacity,
  ffi.Pointer<ffi.Size> out_n,
);

/// Return the realm app for the user passed as parameter.
/// @return a ptr to the app for the user.
@ffi.Native<ffi.Pointer<realm_app_t> Function(ffi.Pointer<realm_user_t>)>(symbol: 'realm_user_get_app')
external ffi.Pointer<realm_app_t> realm_user_get_app(
  ffi.Pointer<realm_user_t> arg0,
);

/// Get the custom user data from the user's access token.
///
/// Returned value must be manually released with realm_free().
///
/// @return An Extended JSON document serialized as string,
/// or null if token doesn't have any custom data.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<realm_user_t>)>(symbol: 'realm_user_get_custom_data')
external ffi.Pointer<ffi.Char> realm_user_get_custom_data(
  ffi.Pointer<realm_user_t> arg0,
);

/// returned pointer must be manually released with realm_free()
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<realm_user_t>)>(symbol: 'realm_user_get_device_id')
external ffi.Pointer<ffi.Char> realm_user_get_device_id(
  ffi.Pointer<realm_user_t> arg0,
);

/// Return the identiy for the user passed as argument
/// @param user ptr to the user for which the identiy has to be retrieved
/// @return a ptr to the identity string
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<realm_user_t>)>(symbol: 'realm_user_get_identity')
external ffi.Pointer<ffi.Char> realm_user_get_identity(
  ffi.Pointer<realm_user_t> user,
);

/// Get the user profile associated with this user.
///
/// Returned value must be manually released with realm_free().
///
/// @return An Extended JSON document serialized as string,
/// or null if an error occurred.
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<realm_user_t>)>(symbol: 'realm_user_get_profile_data')
external ffi.Pointer<ffi.Char> realm_user_get_profile_data(
  ffi.Pointer<realm_user_t> arg0,
);

/// Return the refresh token associated with the user.
/// @return a string that represents the refresh token
@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<realm_user_t>)>(symbol: 'realm_user_get_refresh_token')
external ffi.Pointer<ffi.Char> realm_user_get_refresh_token(
  ffi.Pointer<realm_user_t> arg0,
);

/// Retrieve the state for the user passed as argument
/// @param user ptr to the user for which the state has to be retrieved
/// @return realm_user_state_e value
@ffi.Native<ffi.Int32 Function(ffi.Pointer<realm_user_t>)>(symbol: 'realm_user_get_state')
external int realm_user_get_state(
  ffi.Pointer<realm_user_t> user,
);

@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_user_t>)>(symbol: 'realm_user_is_logged_in')
external bool realm_user_is_logged_in(
  ffi.Pointer<realm_user_t> arg0,
);

/// Log out the user and mark it as logged out.
///
/// Any active sync sessions associated with this user will be stopped.
///
/// @return true, if no errors occurred.
@ffi.Native<ffi.Bool Function(ffi.Pointer<realm_user_t>)>(symbol: 'realm_user_log_out')
external bool realm_user_log_out(
  ffi.Pointer<realm_user_t> arg0,
);

/// A port is used to send or receive inter-isolate messages
typedef Dart_Port = ffi.Int64;
typedef DartDart_Port = int;

final class UnnamedUnion1 extends ffi.Union {
  @ffi.Int64()
  external int integer;

  @ffi.Bool()
  external bool boolean;

  external realm_string_t string;

  external realm_binary_t binary;

  external realm_timestamp_t timestamp;

  @ffi.Float()
  external double fnum;

  @ffi.Double()
  external double dnum;

  external realm_decimal128_t decimal128;

  external realm_object_id_t object_id;

  external realm_uuid_t uuid;

  external realm_link_t link;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> data;
}

final class realm_app extends ffi.Opaque {}

final class realm_app_config extends ffi.Opaque {}

typedef realm_app_config_t = realm_app_config;

final class realm_app_credentials extends ffi.Opaque {}

typedef realm_app_credentials_t = realm_app_credentials;

/// This type should never be returned from a function.
/// It's only meant as an asynchronous callback argument.
/// Pointers to this struct and its pointer members are only valid inside the scope
/// of the callback they were passed to.
final class realm_app_error extends ffi.Struct {
  @ffi.Int32()
  external int error;

  @realm_error_categories()
  external int categories;

  external ffi.Pointer<ffi.Char> message;

  /// The underlying HTTP status code returned by the server,
  /// otherwise zero.
  @ffi.Int()
  external int http_status_code;

  /// A link to MongoDB Realm server logs related to the error,
  /// or NULL if error response didn't contain log information.
  external ffi.Pointer<ffi.Char> link_to_server_logs;
}

/// This type should never be returned from a function.
/// It's only meant as an asynchronous callback argument.
/// Pointers to this struct and its pointer members are only valid inside the scope
/// of the callback they were passed to.
typedef realm_app_error_t = realm_app_error;

/// App
typedef realm_app_t = realm_app;

final class realm_app_user_apikey extends ffi.Struct {
  external realm_object_id_t id;

  external ffi.Pointer<ffi.Char> key;

  external ffi.Pointer<ffi.Char> name;

  @ffi.Bool()
  external bool disabled;
}

typedef realm_app_user_apikey_t = realm_app_user_apikey;

/// Completion callback for asynchronous Realm App operations that yield a user object.
///
/// @param user User object produced by the operation, or null if it failed.
/// The pointer is alive only for the duration of the callback,
/// if you wish to use it further make a copy with realm_clone().
/// @param error Pointer to an error object if the operation failed, otherwise null if it completed successfully.
typedef realm_app_user_completion_func_t = ffi.Pointer<ffi.NativeFunction<realm_app_user_completion_func_tFunction>>;
typedef realm_app_user_completion_func_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_user_t> user, ffi.Pointer<realm_app_error_t> error);
typedef Dartrealm_app_user_completion_func_tFunction = void Function(
    ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_user_t> user, ffi.Pointer<realm_app_error_t> error);

/// Generic completion callback for asynchronous Realm App operations.
///
/// @param error Pointer to an error object if the operation failed, otherwise null if it completed successfully.
typedef realm_app_void_completion_func_t = ffi.Pointer<ffi.NativeFunction<realm_app_void_completion_func_tFunction>>;
typedef realm_app_void_completion_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_app_error_t> error);
typedef Dartrealm_app_void_completion_func_tFunction = void Function(ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_app_error_t> error);
typedef realm_async_begin_write_func_t = ffi.Pointer<ffi.NativeFunction<realm_async_begin_write_func_tFunction>>;
typedef realm_async_begin_write_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void> userdata);
typedef Dartrealm_async_begin_write_func_tFunction = void Function(ffi.Pointer<ffi.Void> userdata);
typedef realm_async_commit_func_t = ffi.Pointer<ffi.NativeFunction<realm_async_commit_func_tFunction>>;
typedef realm_async_commit_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void> userdata, ffi.Bool error, ffi.Pointer<ffi.Char> desc);
typedef Dartrealm_async_commit_func_tFunction = void Function(ffi.Pointer<ffi.Void> userdata, bool error, ffi.Pointer<ffi.Char> desc);

final class realm_async_error extends ffi.Opaque {}

/// Error types
typedef realm_async_error_t = realm_async_error;

final class realm_async_open_task extends ffi.Opaque {}

/// invoked when the synchronized realm file has been downloaded
typedef realm_async_open_task_completion_func_t = ffi.Pointer<ffi.NativeFunction<realm_async_open_task_completion_func_tFunction>>;
typedef realm_async_open_task_completion_func_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_thread_safe_reference_t> realm, ffi.Pointer<realm_async_error_t> error);
typedef Dartrealm_async_open_task_completion_func_tFunction = void Function(
    ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_thread_safe_reference_t> realm, ffi.Pointer<realm_async_error_t> error);

/// invoked once the file has been downloaded. Allows the caller to run some initial subscription before the completion
/// callback runs.
typedef realm_async_open_task_init_subscription_func_t = ffi.Pointer<ffi.NativeFunction<realm_async_open_task_init_subscription_func_tFunction>>;
typedef realm_async_open_task_init_subscription_func_tFunction = ffi.Void Function(ffi.Pointer<realm_t> realm, ffi.Pointer<ffi.Void> userdata);
typedef Dartrealm_async_open_task_init_subscription_func_tFunction = void Function(ffi.Pointer<realm_t> realm, ffi.Pointer<ffi.Void> userdata);

final class realm_async_open_task_progress_notification_token extends ffi.Opaque {}

typedef realm_async_open_task_progress_notification_token_t = realm_async_open_task_progress_notification_token;
typedef realm_async_open_task_t = realm_async_open_task;

abstract class realm_auth_provider {
  static const int RLM_AUTH_PROVIDER_ANONYMOUS = 0;
  static const int RLM_AUTH_PROVIDER_ANONYMOUS_NO_REUSE = 1;
  static const int RLM_AUTH_PROVIDER_FACEBOOK = 2;
  static const int RLM_AUTH_PROVIDER_GOOGLE = 3;
  static const int RLM_AUTH_PROVIDER_APPLE = 4;
  static const int RLM_AUTH_PROVIDER_CUSTOM = 5;
  static const int RLM_AUTH_PROVIDER_EMAIL_PASSWORD = 6;
  static const int RLM_AUTH_PROVIDER_FUNCTION = 7;
  static const int RLM_AUTH_PROVIDER_API_KEY = 8;
}

final class realm_binary extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> data;

  @ffi.Size()
  external int size;
}

typedef realm_binary_t = realm_binary;

final class realm_callback_token extends ffi.Opaque {}

typedef realm_callback_token_t = realm_callback_token;

abstract class realm_class_flags {
  static const int RLM_CLASS_NORMAL = 0;
  static const int RLM_CLASS_EMBEDDED = 1;
  static const int RLM_CLASS_ASYMMETRIC = 2;
  static const int RLM_CLASS_MASK = 3;
}

final class realm_class_info extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  external ffi.Pointer<ffi.Char> primary_key;

  @ffi.Size()
  external int num_properties;

  @ffi.Size()
  external int num_computed_properties;

  @realm_class_key_t()
  external int key;

  @ffi.Int()
  external int flags;
}

typedef realm_class_info_t = realm_class_info;

/// Key types
typedef realm_class_key_t = ffi.Uint32;
typedef Dartrealm_class_key_t = int;

final class realm_collection_changes extends ffi.Opaque {}

typedef realm_collection_changes_t = realm_collection_changes;

final class realm_collection_move extends ffi.Struct {
  @ffi.Size()
  external int from;

  @ffi.Size()
  external int to;
}

typedef realm_collection_move_t = realm_collection_move;

abstract class realm_collection_type {
  static const int RLM_COLLECTION_TYPE_NONE = 0;
  static const int RLM_COLLECTION_TYPE_LIST = 1;
  static const int RLM_COLLECTION_TYPE_SET = 2;
  static const int RLM_COLLECTION_TYPE_DICTIONARY = 4;
}

/// Schema types
abstract class realm_column_attr {
  /// Values matching `realm::ColumnAttr`.
  static const int RLM_COLUMN_ATTR_NONE = 0;
  static const int RLM_COLUMN_ATTR_INDEXED = 1;
  static const int RLM_COLUMN_ATTR_UNIQUE = 2;
  static const int RLM_COLUMN_ATTR_RESERVED = 4;
  static const int RLM_COLUMN_ATTR_STRONG_LINKS = 8;
  static const int RLM_COLUMN_ATTR_NULLABLE = 16;
  static const int RLM_COLUMN_ATTR_LIST = 32;
  static const int RLM_COLUMN_ATTR_DICTIONARY = 64;
  static const int RLM_COLUMN_ATTR_COLLECTION = 96;
}

final class realm_config extends ffi.Opaque {}

/// Config types
typedef realm_config_t = realm_config;

final class realm_dart_userdata_async extends ffi.Opaque {}

typedef realm_dart_userdata_async_t = ffi.Pointer<realm_dart_userdata_async>;
typedef realm_data_initialization_func_t = ffi.Pointer<ffi.NativeFunction<realm_data_initialization_func_tFunction>>;
typedef realm_data_initialization_func_tFunction = ffi.Bool Function(ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_t> realm);
typedef Dartrealm_data_initialization_func_tFunction = bool Function(ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_t> realm);

final class realm_decimal128 extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Uint64> w;
}

typedef realm_decimal128_t = realm_decimal128;

final class realm_dictionary extends ffi.Opaque {}

final class realm_dictionary_changes extends ffi.Opaque {}

typedef realm_dictionary_changes_t = realm_dictionary_changes;
typedef realm_dictionary_t = realm_dictionary;

abstract class realm_errno {
  static const int RLM_ERR_NONE = 0;
  static const int RLM_ERR_RUNTIME = 1000;
  static const int RLM_ERR_RANGE_ERROR = 1001;
  static const int RLM_ERR_BROKEN_INVARIANT = 1002;
  static const int RLM_ERR_OUT_OF_MEMORY = 1003;
  static const int RLM_ERR_OUT_OF_DISK_SPACE = 1004;
  static const int RLM_ERR_ADDRESS_SPACE_EXHAUSTED = 1005;
  static const int RLM_ERR_MAXIMUM_FILE_SIZE_EXCEEDED = 1006;
  static const int RLM_ERR_INCOMPATIBLE_SESSION = 1007;
  static const int RLM_ERR_INCOMPATIBLE_LOCK_FILE = 1008;
  static const int RLM_ERR_INVALID_QUERY = 1009;
  static const int RLM_ERR_BAD_VERSION = 1010;
  static const int RLM_ERR_UNSUPPORTED_FILE_FORMAT_VERSION = 1011;
  static const int RLM_ERR_MULTIPLE_SYNC_AGENTS = 1012;
  static const int RLM_ERR_OBJECT_ALREADY_EXISTS = 1013;
  static const int RLM_ERR_NOT_CLONABLE = 1014;
  static const int RLM_ERR_BAD_CHANGESET = 1015;
  static const int RLM_ERR_SUBSCRIPTION_FAILED = 1016;
  static const int RLM_ERR_FILE_OPERATION_FAILED = 1017;
  static const int RLM_ERR_FILE_PERMISSION_DENIED = 1018;
  static const int RLM_ERR_FILE_NOT_FOUND = 1019;
  static const int RLM_ERR_FILE_ALREADY_EXISTS = 1020;
  static const int RLM_ERR_INVALID_DATABASE = 1021;
  static const int RLM_ERR_DECRYPTION_FAILED = 1022;
  static const int RLM_ERR_INCOMPATIBLE_HISTORIES = 1023;
  static const int RLM_ERR_FILE_FORMAT_UPGRADE_REQUIRED = 1024;
  static const int RLM_ERR_SCHEMA_VERSION_MISMATCH = 1025;
  static const int RLM_ERR_NO_SUBSCRIPTION_FOR_WRITE = 1026;
  static const int RLM_ERR_OPERATION_ABORTED = 1027;
  static const int RLM_ERR_AUTO_CLIENT_RESET_FAILED = 1028;
  static const int RLM_ERR_BAD_SYNC_PARTITION_VALUE = 1029;
  static const int RLM_ERR_CONNECTION_CLOSED = 1030;
  static const int RLM_ERR_INVALID_SUBSCRIPTION_QUERY = 1031;
  static const int RLM_ERR_SYNC_CLIENT_RESET_REQUIRED = 1032;
  static const int RLM_ERR_SYNC_COMPENSATING_WRITE = 1033;
  static const int RLM_ERR_SYNC_CONNECT_FAILED = 1034;
  static const int RLM_ERR_SYNC_CONNECT_TIMEOUT = 1035;
  static const int RLM_ERR_SYNC_INVALID_SCHEMA_CHANGE = 1036;
  static const int RLM_ERR_SYNC_PERMISSION_DENIED = 1037;
  static const int RLM_ERR_SYNC_PROTOCOL_INVARIANT_FAILED = 1038;
  static const int RLM_ERR_SYNC_PROTOCOL_NEGOTIATION_FAILED = 1039;
  static const int RLM_ERR_SYNC_SERVER_PERMISSIONS_CHANGED = 1040;
  static const int RLM_ERR_SYNC_USER_MISMATCH = 1041;
  static const int RLM_ERR_TLS_HANDSHAKE_FAILED = 1042;
  static const int RLM_ERR_WRONG_SYNC_TYPE = 1043;
  static const int RLM_ERR_SYNC_WRITE_NOT_ALLOWED = 1044;
  static const int RLM_ERR_SYNC_LOCAL_CLOCK_BEFORE_EPOCH = 1045;
  static const int RLM_ERR_SYNC_SCHEMA_MIGRATION_ERROR = 1046;
  static const int RLM_ERR_SYSTEM_ERROR = 1999;
  static const int RLM_ERR_LOGIC = 2000;
  static const int RLM_ERR_NOT_SUPPORTED = 2001;
  static const int RLM_ERR_BROKEN_PROMISE = 2002;
  static const int RLM_ERR_CROSS_TABLE_LINK_TARGET = 2003;
  static const int RLM_ERR_KEY_ALREADY_USED = 2004;
  static const int RLM_ERR_WRONG_TRANSACTION_STATE = 2005;
  static const int RLM_ERR_WRONG_THREAD = 2006;
  static const int RLM_ERR_ILLEGAL_OPERATION = 2007;
  static const int RLM_ERR_SERIALIZATION_ERROR = 2008;
  static const int RLM_ERR_STALE_ACCESSOR = 2009;
  static const int RLM_ERR_INVALIDATED_OBJECT = 2010;
  static const int RLM_ERR_READ_ONLY_DB = 2011;
  static const int RLM_ERR_DELETE_OPENED_REALM = 2012;
  static const int RLM_ERR_MISMATCHED_CONFIG = 2013;
  static const int RLM_ERR_CLOSED_REALM = 2014;
  static const int RLM_ERR_INVALID_TABLE_REF = 2015;
  static const int RLM_ERR_SCHEMA_VALIDATION_FAILED = 2016;
  static const int RLM_ERR_SCHEMA_MISMATCH = 2017;
  static const int RLM_ERR_INVALID_SCHEMA_VERSION = 2018;
  static const int RLM_ERR_INVALID_SCHEMA_CHANGE = 2019;
  static const int RLM_ERR_MIGRATION_FAILED = 2020;
  static const int RLM_ERR_TOP_LEVEL_OBJECT = 2021;
  static const int RLM_ERR_INVALID_ARGUMENT = 3000;
  static const int RLM_ERR_PROPERTY_TYPE_MISMATCH = 3001;
  static const int RLM_ERR_PROPERTY_NOT_NULLABLE = 3002;
  static const int RLM_ERR_READ_ONLY_PROPERTY = 3003;
  static const int RLM_ERR_MISSING_PROPERTY_VALUE = 3004;
  static const int RLM_ERR_MISSING_PRIMARY_KEY = 3005;
  static const int RLM_ERR_UNEXPECTED_PRIMARY_KEY = 3006;
  static const int RLM_ERR_MODIFY_PRIMARY_KEY = 3007;
  static const int RLM_ERR_INVALID_QUERY_STRING = 3008;
  static const int RLM_ERR_INVALID_PROPERTY = 3009;
  static const int RLM_ERR_INVALID_NAME = 3010;
  static const int RLM_ERR_INVALID_DICTIONARY_KEY = 3011;
  static const int RLM_ERR_INVALID_DICTIONARY_VALUE = 3012;
  static const int RLM_ERR_INVALID_SORT_DESCRIPTOR = 3013;
  static const int RLM_ERR_INVALID_ENCRYPTION_KEY = 3014;
  static const int RLM_ERR_INVALID_QUERY_ARG = 3015;
  static const int RLM_ERR_NO_SUCH_OBJECT = 3016;
  static const int RLM_ERR_INDEX_OUT_OF_BOUNDS = 3017;
  static const int RLM_ERR_LIMIT_EXCEEDED = 3018;
  static const int RLM_ERR_OBJECT_TYPE_MISMATCH = 3019;
  static const int RLM_ERR_NO_SUCH_TABLE = 3020;
  static const int RLM_ERR_TABLE_NAME_IN_USE = 3021;
  static const int RLM_ERR_ILLEGAL_COMBINATION = 3022;
  static const int RLM_ERR_BAD_SERVER_URL = 3023;
  static const int RLM_ERR_CUSTOM_ERROR = 4000;
  static const int RLM_ERR_CLIENT_USER_NOT_FOUND = 4100;
  static const int RLM_ERR_CLIENT_USER_NOT_LOGGED_IN = 4101;
  static const int RLM_ERR_CLIENT_APP_DEALLOCATED = 4102;
  static const int RLM_ERR_CLIENT_REDIRECT_ERROR = 4103;
  static const int RLM_ERR_CLIENT_TOO_MANY_REDIRECTS = 4104;
  static const int RLM_ERR_BAD_TOKEN = 4200;
  static const int RLM_ERR_MALFORMED_JSON = 4201;
  static const int RLM_ERR_MISSING_JSON_KEY = 4202;
  static const int RLM_ERR_BAD_BSON_PARSE = 4203;
  static const int RLM_ERR_MISSING_AUTH_REQ = 4300;
  static const int RLM_ERR_INVALID_SESSION = 4301;
  static const int RLM_ERR_USER_APP_DOMAIN_MISMATCH = 4302;
  static const int RLM_ERR_DOMAIN_NOT_ALLOWED = 4303;
  static const int RLM_ERR_READ_SIZE_LIMIT_EXCEEDED = 4304;
  static const int RLM_ERR_INVALID_PARAMETER = 4305;
  static const int RLM_ERR_MISSING_PARAMETER = 4306;
  static const int RLM_ERR_TWILIO_ERROR = 4307;
  static const int RLM_ERR_GCM_ERROR = 4308;
  static const int RLM_ERR_HTTP_ERROR = 4309;
  static const int RLM_ERR_AWS_ERROR = 4310;
  static const int RLM_ERR_MONGODB_ERROR = 4311;
  static const int RLM_ERR_ARGUMENTS_NOT_ALLOWED = 4312;
  static const int RLM_ERR_FUNCTION_EXECUTION_ERROR = 4313;
  static const int RLM_ERR_NO_MATCHING_RULE_FOUND = 4314;
  static const int RLM_ERR_INTERNAL_SERVER_ERROR = 4315;
  static const int RLM_ERR_AUTH_PROVIDER_NOT_FOUND = 4316;
  static const int RLM_ERR_AUTH_PROVIDER_ALREADY_EXISTS = 4317;
  static const int RLM_ERR_SERVICE_NOT_FOUND = 4318;
  static const int RLM_ERR_SERVICE_TYPE_NOT_FOUND = 4319;
  static const int RLM_ERR_SERVICE_ALREADY_EXISTS = 4320;
  static const int RLM_ERR_SERVICE_COMMAND_NOT_FOUND = 4321;
  static const int RLM_ERR_VALUE_NOT_FOUND = 4322;
  static const int RLM_ERR_VALUE_ALREADY_EXISTS = 4323;
  static const int RLM_ERR_VALUE_DUPLICATE_NAME = 4324;
  static const int RLM_ERR_FUNCTION_NOT_FOUND = 4325;
  static const int RLM_ERR_FUNCTION_ALREADY_EXISTS = 4326;
  static const int RLM_ERR_FUNCTION_DUPLICATE_NAME = 4327;
  static const int RLM_ERR_FUNCTION_SYNTAX_ERROR = 4328;
  static const int RLM_ERR_FUNCTION_INVALID = 4329;
  static const int RLM_ERR_INCOMING_WEBHOOK_NOT_FOUND = 4330;
  static const int RLM_ERR_INCOMING_WEBHOOK_ALREADY_EXISTS = 4331;
  static const int RLM_ERR_INCOMING_WEBHOOK_DUPLICATE_NAME = 4332;
  static const int RLM_ERR_RULE_NOT_FOUND = 4333;
  static const int RLM_ERR_API_KEY_NOT_FOUND = 4334;
  static const int RLM_ERR_RULE_ALREADY_EXISTS = 4335;
  static const int RLM_ERR_RULE_DUPLICATE_NAME = 4336;
  static const int RLM_ERR_AUTH_PROVIDER_DUPLICATE_NAME = 4337;
  static const int RLM_ERR_RESTRICTED_HOST = 4338;
  static const int RLM_ERR_API_KEY_ALREADY_EXISTS = 4339;
  static const int RLM_ERR_INCOMING_WEBHOOK_AUTH_FAILED = 4340;
  static const int RLM_ERR_EXECUTION_TIME_LIMIT_EXCEEDED = 4341;
  static const int RLM_ERR_NOT_CALLABLE = 4342;
  static const int RLM_ERR_USER_ALREADY_CONFIRMED = 4343;
  static const int RLM_ERR_USER_NOT_FOUND = 4344;
  static const int RLM_ERR_USER_DISABLED = 4345;
  static const int RLM_ERR_AUTH_ERROR = 4346;
  static const int RLM_ERR_BAD_REQUEST = 4347;
  static const int RLM_ERR_ACCOUNT_NAME_IN_USE = 4348;
  static const int RLM_ERR_INVALID_PASSWORD = 4349;
  static const int RLM_ERR_SCHEMA_VALIDATION_FAILED_WRITE = 4350;
  static const int RLM_ERR_APP_UNKNOWN = 4351;
  static const int RLM_ERR_MAINTENANCE_IN_PROGRESS = 4352;
  static const int RLM_ERR_USERPASS_TOKEN_INVALID = 4353;
  static const int RLM_ERR_INVALID_SERVER_RESPONSE = 4354;
  static const int RLM_ERR_APP_SERVER_ERROR = 4355;

  /// < A user-provided callback failed.
  static const int RLM_ERR_CALLBACK = 1000000;

  /// Should not be used in code
  static const int RLM_ERR_UNKNOWN = 2000000;
}

final class realm_error extends ffi.Struct {
  @ffi.Int32()
  external int error;

  @realm_error_categories()
  external int categories;

  external ffi.Pointer<ffi.Char> message;

  /// When error is RLM_ERR_CALLBACK this is an opaque pointer to an SDK-owned error object
  /// thrown by user code inside a callback with realm_register_user_code_callback_error(), otherwise null.
  external ffi.Pointer<ffi.Void> user_code_error;

  external ffi.Pointer<ffi.Char> path;
}

typedef realm_error_categories = ffi.UnsignedInt;
typedef Dartrealm_error_categories = int;
typedef realm_error_t = realm_error;

final class realm_flx_sync_mutable_subscription_set extends ffi.Opaque {}

typedef realm_flx_sync_mutable_subscription_set_t = realm_flx_sync_mutable_subscription_set;

final class realm_flx_sync_subscription extends ffi.Opaque {}

final class realm_flx_sync_subscription_desc extends ffi.Opaque {}

final class realm_flx_sync_subscription_set extends ffi.Opaque {}

abstract class realm_flx_sync_subscription_set_state {
  static const int RLM_SYNC_SUBSCRIPTION_UNCOMMITTED = 0;
  static const int RLM_SYNC_SUBSCRIPTION_PENDING = 1;
  static const int RLM_SYNC_SUBSCRIPTION_BOOTSTRAPPING = 2;
  static const int RLM_SYNC_SUBSCRIPTION_COMPLETE = 3;
  static const int RLM_SYNC_SUBSCRIPTION_ERROR = 4;
  static const int RLM_SYNC_SUBSCRIPTION_SUPERSEDED = 5;
  static const int RLM_SYNC_SUBSCRIPTION_AWAITING_MARK = 6;
}

typedef realm_flx_sync_subscription_set_t = realm_flx_sync_subscription_set;
typedef realm_flx_sync_subscription_t = realm_flx_sync_subscription;
typedef realm_free_userdata_func_t = ffi.Pointer<ffi.NativeFunction<realm_free_userdata_func_tFunction>>;
typedef realm_free_userdata_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void> userdata);
typedef Dartrealm_free_userdata_func_tFunction = void Function(ffi.Pointer<ffi.Void> userdata);

final class realm_http_header extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  external ffi.Pointer<ffi.Char> value;
}

typedef realm_http_header_t = realm_http_header;

final class realm_http_request extends ffi.Struct {
  @ffi.Int32()
  external int method;

  external ffi.Pointer<ffi.Char> url;

  @ffi.Uint64()
  external int timeout_ms;

  external ffi.Pointer<realm_http_header_t> headers;

  @ffi.Size()
  external int num_headers;

  external ffi.Pointer<ffi.Char> body;

  @ffi.Size()
  external int body_size;
}

/// Callback function used by Core to make a HTTP request.
///
/// Complete the request by calling realm_http_transport_complete_request(),
/// passing in the request_context pointer here and the received response.
/// Network request are expected to be asynchronous and can be completed on any thread.
///
/// @param request The request to send.
/// @param request_context Internal state pointer of Core, needed by realm_http_transport_complete_request().
typedef realm_http_request_func_t = ffi.Pointer<ffi.NativeFunction<realm_http_request_func_tFunction>>;
typedef realm_http_request_func_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void> userdata, realm_http_request_t request, ffi.Pointer<ffi.Void> request_context);
typedef Dartrealm_http_request_func_tFunction = void Function(
    ffi.Pointer<ffi.Void> userdata, realm_http_request_t request, ffi.Pointer<ffi.Void> request_context);

/// HTTP transport
abstract class realm_http_request_method {
  static const int RLM_HTTP_REQUEST_METHOD_GET = 0;
  static const int RLM_HTTP_REQUEST_METHOD_POST = 1;
  static const int RLM_HTTP_REQUEST_METHOD_PATCH = 2;
  static const int RLM_HTTP_REQUEST_METHOD_PUT = 3;
  static const int RLM_HTTP_REQUEST_METHOD_DELETE = 4;
}

typedef realm_http_request_t = realm_http_request;

final class realm_http_response extends ffi.Struct {
  @ffi.Int()
  external int status_code;

  @ffi.Int()
  external int custom_status_code;

  external ffi.Pointer<realm_http_header_t> headers;

  @ffi.Size()
  external int num_headers;

  external ffi.Pointer<ffi.Char> body;

  @ffi.Size()
  external int body_size;
}

typedef realm_http_response_t = realm_http_response;

final class realm_http_transport extends ffi.Opaque {}

typedef realm_http_transport_t = realm_http_transport;

final class realm_index_range extends ffi.Struct {
  @ffi.Size()
  external int from;

  @ffi.Size()
  external int to;
}

typedef realm_index_range_t = realm_index_range;

final class realm_key_path_array extends ffi.Opaque {}

typedef realm_key_path_array_t = realm_key_path_array;

final class realm_link extends ffi.Struct {
  @realm_class_key_t()
  external int target_table;

  @realm_object_key_t()
  external int target;
}

typedef realm_link_t = realm_link;

final class realm_list extends ffi.Opaque {}

typedef realm_list_t = realm_list;
typedef realm_log_func_t = ffi.Pointer<ffi.NativeFunction<realm_log_func_tFunction>>;
typedef realm_log_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void> userdata, ffi.Int32 level, ffi.Pointer<ffi.Char> message);
typedef Dartrealm_log_func_tFunction = void Function(ffi.Pointer<ffi.Void> userdata, int level, ffi.Pointer<ffi.Char> message);

/// Logging */
/// // equivalent to realm::util::Logger::Level in util/logger.hpp and must be kept in sync.
abstract class realm_log_level {
  static const int RLM_LOG_LEVEL_ALL = 0;
  static const int RLM_LOG_LEVEL_TRACE = 1;
  static const int RLM_LOG_LEVEL_DEBUG = 2;
  static const int RLM_LOG_LEVEL_DETAIL = 3;
  static const int RLM_LOG_LEVEL_INFO = 4;
  static const int RLM_LOG_LEVEL_WARNING = 5;
  static const int RLM_LOG_LEVEL_ERROR = 6;
  static const int RLM_LOG_LEVEL_FATAL = 7;
  static const int RLM_LOG_LEVEL_OFF = 8;
}

typedef realm_migration_func_t = ffi.Pointer<ffi.NativeFunction<realm_migration_func_tFunction>>;
typedef realm_migration_func_tFunction = ffi.Bool Function(
    ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_t> old_realm, ffi.Pointer<realm_t> new_realm, ffi.Pointer<realm_schema_t> schema);
typedef Dartrealm_migration_func_tFunction = bool Function(
    ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_t> old_realm, ffi.Pointer<realm_t> new_realm, ffi.Pointer<realm_schema_t> schema);
typedef realm_mongodb_callback_t = ffi.Pointer<ffi.NativeFunction<realm_mongodb_callback_tFunction>>;
typedef realm_mongodb_callback_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void> userdata, realm_string_t bson, ffi.Pointer<realm_app_error_t> app_error);
typedef Dartrealm_mongodb_callback_tFunction = void Function(ffi.Pointer<ffi.Void> userdata, realm_string_t bson, ffi.Pointer<realm_app_error_t> app_error);

final class realm_mongodb_collection extends ffi.Opaque {}

typedef realm_mongodb_collection_t = realm_mongodb_collection;

final class realm_mongodb_find_one_and_modify_options extends ffi.Struct {
  external realm_string_t projection_bson;

  external realm_string_t sort_bson;

  @ffi.Bool()
  external bool upsert;

  @ffi.Bool()
  external bool return_new_document;
}

typedef realm_mongodb_find_one_and_modify_options_t = realm_mongodb_find_one_and_modify_options;

final class realm_mongodb_find_options extends ffi.Struct {
  external realm_string_t projection_bson;

  external realm_string_t sort_bson;

  @ffi.Int64()
  external int limit;
}

typedef realm_mongodb_find_options_t = realm_mongodb_find_options;

final class realm_notification_token extends ffi.Opaque {}

/// Notification types
typedef realm_notification_token_t = realm_notification_token;

final class realm_object extends ffi.Opaque {}

final class realm_object_changes extends ffi.Opaque {}

typedef realm_object_changes_t = realm_object_changes;

final class realm_object_id extends ffi.Struct {
  @ffi.Array.multi([12])
  external ffi.Array<ffi.Uint8> bytes;
}

typedef realm_object_id_t = realm_object_id;
typedef realm_object_key_t = ffi.Int64;
typedef Dartrealm_object_key_t = int;

/// Accessor types
typedef realm_object_t = realm_object;
typedef realm_on_collection_change_func_t = ffi.Pointer<ffi.NativeFunction<realm_on_collection_change_func_tFunction>>;
typedef realm_on_collection_change_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<realm_collection_changes_t>);
typedef Dartrealm_on_collection_change_func_tFunction = void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<realm_collection_changes_t>);
typedef realm_on_dictionary_change_func_t = ffi.Pointer<ffi.NativeFunction<realm_on_dictionary_change_func_tFunction>>;
typedef realm_on_dictionary_change_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<realm_dictionary_changes_t>);
typedef Dartrealm_on_dictionary_change_func_tFunction = void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<realm_dictionary_changes_t>);
typedef realm_on_object_change_func_t = ffi.Pointer<ffi.NativeFunction<realm_on_object_change_func_tFunction>>;
typedef realm_on_object_change_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<realm_object_changes_t>);
typedef Dartrealm_on_object_change_func_tFunction = void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<realm_object_changes_t>);
typedef realm_on_object_store_error_callback_t = ffi.Pointer<ffi.NativeFunction<realm_on_object_store_error_callback_tFunction>>;
typedef realm_on_object_store_error_callback_tFunction = ffi.Bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>);
typedef Dartrealm_on_object_store_error_callback_tFunction = bool Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>);
typedef realm_on_object_store_thread_callback_t = ffi.Pointer<ffi.NativeFunction<realm_on_object_store_thread_callback_tFunction>>;
typedef realm_on_object_store_thread_callback_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void> userdata);
typedef Dartrealm_on_object_store_thread_callback_tFunction = void Function(ffi.Pointer<ffi.Void> userdata);
typedef realm_on_realm_change_func_t = ffi.Pointer<ffi.NativeFunction<realm_on_realm_change_func_tFunction>>;
typedef realm_on_realm_change_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void> userdata);
typedef Dartrealm_on_realm_change_func_tFunction = void Function(ffi.Pointer<ffi.Void> userdata);
typedef realm_on_realm_refresh_func_t = ffi.Pointer<ffi.NativeFunction<realm_on_realm_refresh_func_tFunction>>;
typedef realm_on_realm_refresh_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void> userdata);
typedef Dartrealm_on_realm_refresh_func_tFunction = void Function(ffi.Pointer<ffi.Void> userdata);

/// Callback for realm schema changed notifications.
///
/// @param new_schema The new schema. This object is released after the callback returns.
/// Preserve it with realm_clone() if you wish to keep it around for longer.
typedef realm_on_schema_change_func_t = ffi.Pointer<ffi.NativeFunction<realm_on_schema_change_func_tFunction>>;
typedef realm_on_schema_change_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_schema_t> new_schema);
typedef Dartrealm_on_schema_change_func_tFunction = void Function(ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_schema_t> new_schema);

abstract class realm_property_flags {
  static const int RLM_PROPERTY_NORMAL = 0;
  static const int RLM_PROPERTY_NULLABLE = 1;
  static const int RLM_PROPERTY_PRIMARY_KEY = 2;
  static const int RLM_PROPERTY_INDEXED = 4;
  static const int RLM_PROPERTY_FULLTEXT_INDEXED = 8;
}

final class realm_property_info extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  external ffi.Pointer<ffi.Char> public_name;

  @ffi.Int32()
  external int type;

  @ffi.Int32()
  external int collection_type;

  external ffi.Pointer<ffi.Char> link_target;

  external ffi.Pointer<ffi.Char> link_origin_property_name;

  @realm_property_key_t()
  external int key;

  @ffi.Int()
  external int flags;
}

typedef realm_property_info_t = realm_property_info;
typedef realm_property_key_t = ffi.Int64;
typedef Dartrealm_property_key_t = int;

abstract class realm_property_type {
  /// Values matching `realm::ColumnType`.
  static const int RLM_PROPERTY_TYPE_INT = 0;
  static const int RLM_PROPERTY_TYPE_BOOL = 1;
  static const int RLM_PROPERTY_TYPE_STRING = 2;
  static const int RLM_PROPERTY_TYPE_BINARY = 4;
  static const int RLM_PROPERTY_TYPE_MIXED = 6;
  static const int RLM_PROPERTY_TYPE_TIMESTAMP = 8;
  static const int RLM_PROPERTY_TYPE_FLOAT = 9;
  static const int RLM_PROPERTY_TYPE_DOUBLE = 10;
  static const int RLM_PROPERTY_TYPE_DECIMAL128 = 11;
  static const int RLM_PROPERTY_TYPE_OBJECT = 12;
  static const int RLM_PROPERTY_TYPE_LINKING_OBJECTS = 14;
  static const int RLM_PROPERTY_TYPE_OBJECT_ID = 15;
  static const int RLM_PROPERTY_TYPE_UUID = 17;
}

final class realm_query extends ffi.Opaque {}

final class realm_query_arg extends ffi.Struct {
  @ffi.Size()
  external int nb_args;

  @ffi.Bool()
  external bool is_list;

  external ffi.Pointer<realm_value_t> arg;
}

typedef realm_query_arg_t = realm_query_arg;

/// Query types
typedef realm_query_t = realm_query;

final class realm_refresh_callback_token extends ffi.Opaque {}

typedef realm_refresh_callback_token_t = realm_refresh_callback_token;

final class realm_results extends ffi.Opaque {}

typedef realm_results_t = realm_results;
typedef realm_return_apikey_func_t = ffi.Pointer<ffi.NativeFunction<realm_return_apikey_func_tFunction>>;
typedef realm_return_apikey_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<realm_app_user_apikey_t>, ffi.Pointer<realm_app_error_t>);
typedef Dartrealm_return_apikey_func_tFunction = void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<realm_app_user_apikey_t>, ffi.Pointer<realm_app_error_t>);
typedef realm_return_apikey_list_func_t = ffi.Pointer<ffi.NativeFunction<realm_return_apikey_list_func_tFunction>>;
typedef realm_return_apikey_list_func_tFunction = ffi.Void Function(
    ffi.Pointer<ffi.Void>, ffi.Pointer<realm_app_user_apikey_t>, ffi.Size, ffi.Pointer<realm_app_error_t>);
typedef Dartrealm_return_apikey_list_func_tFunction = void Function(
    ffi.Pointer<ffi.Void>, ffi.Pointer<realm_app_user_apikey_t>, int, ffi.Pointer<realm_app_error_t>);
typedef realm_return_string_func_t = ffi.Pointer<ffi.NativeFunction<realm_return_string_func_tFunction>>;
typedef realm_return_string_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Pointer<realm_app_error_t>);
typedef Dartrealm_return_string_func_tFunction = void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Pointer<realm_app_error_t>);

final class realm_scheduler extends ffi.Opaque {}

typedef realm_scheduler_can_deliver_notifications_func_t = ffi.Pointer<ffi.NativeFunction<realm_scheduler_can_deliver_notifications_func_tFunction>>;
typedef realm_scheduler_can_deliver_notifications_func_tFunction = ffi.Bool Function(ffi.Pointer<ffi.Void> userdata);
typedef Dartrealm_scheduler_can_deliver_notifications_func_tFunction = bool Function(ffi.Pointer<ffi.Void> userdata);
typedef realm_scheduler_default_factory_func_t = ffi.Pointer<ffi.NativeFunction<realm_scheduler_default_factory_func_tFunction>>;
typedef realm_scheduler_default_factory_func_tFunction = ffi.Pointer<realm_scheduler_t> Function(ffi.Pointer<ffi.Void> userdata);
typedef realm_scheduler_is_on_thread_func_t = ffi.Pointer<ffi.NativeFunction<realm_scheduler_is_on_thread_func_tFunction>>;
typedef realm_scheduler_is_on_thread_func_tFunction = ffi.Bool Function(ffi.Pointer<ffi.Void> userdata);
typedef Dartrealm_scheduler_is_on_thread_func_tFunction = bool Function(ffi.Pointer<ffi.Void> userdata);
typedef realm_scheduler_is_same_as_func_t = ffi.Pointer<ffi.NativeFunction<realm_scheduler_is_same_as_func_tFunction>>;
typedef realm_scheduler_is_same_as_func_tFunction = ffi.Bool Function(ffi.Pointer<ffi.Void> scheduler_userdata_1, ffi.Pointer<ffi.Void> scheduler_userdata_2);
typedef Dartrealm_scheduler_is_same_as_func_tFunction = bool Function(ffi.Pointer<ffi.Void> scheduler_userdata_1, ffi.Pointer<ffi.Void> scheduler_userdata_2);

/// Scheduler types
typedef realm_scheduler_notify_func_t = ffi.Pointer<ffi.NativeFunction<realm_scheduler_notify_func_tFunction>>;
typedef realm_scheduler_notify_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_work_queue_t> work_queue);
typedef Dartrealm_scheduler_notify_func_tFunction = void Function(ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_work_queue_t> work_queue);
typedef realm_scheduler_t = realm_scheduler;

final class realm_schema extends ffi.Opaque {}

abstract class realm_schema_mode {
  static const int RLM_SCHEMA_MODE_AUTOMATIC = 0;
  static const int RLM_SCHEMA_MODE_IMMUTABLE = 1;
  static const int RLM_SCHEMA_MODE_READ_ONLY = 2;
  static const int RLM_SCHEMA_MODE_SOFT_RESET_FILE = 3;
  static const int RLM_SCHEMA_MODE_HARD_RESET_FILE = 4;
  static const int RLM_SCHEMA_MODE_ADDITIVE_DISCOVERED = 5;
  static const int RLM_SCHEMA_MODE_ADDITIVE_EXPLICIT = 6;
  static const int RLM_SCHEMA_MODE_MANUAL = 7;
}

abstract class realm_schema_subset_mode {
  static const int RLM_SCHEMA_SUBSET_MODE_STRICT = 0;
  static const int RLM_SCHEMA_SUBSET_MODE_ALL_CLASSES = 1;
  static const int RLM_SCHEMA_SUBSET_MODE_ALL_PROPERTIES = 2;
  static const int RLM_SCHEMA_SUBSET_MODE_COMPLETE = 3;
}

typedef realm_schema_t = realm_schema;

abstract class realm_schema_validation_mode {
  static const int RLM_SCHEMA_VALIDATION_BASIC = 0;
  static const int RLM_SCHEMA_VALIDATION_SYNC_PBS = 1;
  static const int RLM_SCHEMA_VALIDATION_REJECT_EMBEDDED_ORPHANS = 2;
  static const int RLM_SCHEMA_VALIDATION_SYNC_FLX = 4;
}

final class realm_set extends ffi.Opaque {}

typedef realm_set_t = realm_set;
typedef realm_should_compact_on_launch_func_t = ffi.Pointer<ffi.NativeFunction<realm_should_compact_on_launch_func_tFunction>>;
typedef realm_should_compact_on_launch_func_tFunction = ffi.Bool Function(ffi.Pointer<ffi.Void> userdata, ffi.Uint64 total_bytes, ffi.Uint64 used_bytes);
typedef Dartrealm_should_compact_on_launch_func_tFunction = bool Function(ffi.Pointer<ffi.Void> userdata, int total_bytes, int used_bytes);

/// Represents a view over a UTF-8 string buffer. The buffer is unowned by this struct.
///
/// This string can have three states:
/// - null
/// When the data member is NULL.
/// - empty
/// When the data member is non-NULL, and the size member is 0. The actual contents of the data member in this case
/// don't matter.
/// - non-empty
/// When the data member is non-NULL, and the size member is greater than 0.
final class realm_string extends ffi.Struct {
  external ffi.Pointer<ffi.Char> data;

  @ffi.Size()
  external int size;
}

/// Represents a view over a UTF-8 string buffer. The buffer is unowned by this struct.
///
/// This string can have three states:
/// - null
/// When the data member is NULL.
/// - empty
/// When the data member is non-NULL, and the size member is 0. The actual contents of the data member in this case
/// don't matter.
/// - non-empty
/// When the data member is non-NULL, and the size member is greater than 0.
typedef realm_string_t = realm_string;
typedef realm_sync_after_client_reset_func_t = ffi.Pointer<ffi.NativeFunction<realm_sync_after_client_reset_func_tFunction>>;
typedef realm_sync_after_client_reset_func_tFunction = ffi.Bool Function(
    ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_t> before_realm, ffi.Pointer<realm_thread_safe_reference_t> after_realm, ffi.Bool did_recover);
typedef Dartrealm_sync_after_client_reset_func_tFunction = bool Function(
    ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_t> before_realm, ffi.Pointer<realm_thread_safe_reference_t> after_realm, bool did_recover);
typedef realm_sync_before_client_reset_func_t = ffi.Pointer<ffi.NativeFunction<realm_sync_before_client_reset_func_tFunction>>;
typedef realm_sync_before_client_reset_func_tFunction = ffi.Bool Function(ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_t> before_realm);
typedef Dartrealm_sync_before_client_reset_func_tFunction = bool Function(ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_t> before_realm);

final class realm_sync_client_config extends ffi.Opaque {}

typedef realm_sync_client_config_t = realm_sync_client_config;

/// Sync
abstract class realm_sync_client_metadata_mode {
  static const int RLM_SYNC_CLIENT_METADATA_MODE_PLAINTEXT = 0;
  static const int RLM_SYNC_CLIENT_METADATA_MODE_ENCRYPTED = 1;
  static const int RLM_SYNC_CLIENT_METADATA_MODE_DISABLED = 2;
}

abstract class realm_sync_client_reconnect_mode {
  static const int RLM_SYNC_CLIENT_RECONNECT_MODE_NORMAL = 0;
  static const int RLM_SYNC_CLIENT_RECONNECT_MODE_TESTING = 1;
}

final class realm_sync_config extends ffi.Opaque {}

typedef realm_sync_config_t = realm_sync_config;

abstract class realm_sync_connection_state {
  static const int RLM_SYNC_CONNECTION_STATE_DISCONNECTED = 0;
  static const int RLM_SYNC_CONNECTION_STATE_CONNECTING = 1;
  static const int RLM_SYNC_CONNECTION_STATE_CONNECTED = 2;
}

typedef realm_sync_connection_state_changed_func_t = ffi.Pointer<ffi.NativeFunction<realm_sync_connection_state_changed_func_tFunction>>;
typedef realm_sync_connection_state_changed_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void> userdata, ffi.Int32 old_state, ffi.Int32 new_state);
typedef Dartrealm_sync_connection_state_changed_func_tFunction = void Function(ffi.Pointer<ffi.Void> userdata, int old_state, int new_state);

/// This type should never be returned from a function.
/// It's only meant as an asynchronous callback argument.
/// Pointers to this struct and its pointer members are only valid inside the scope
/// of the callback they were passed to.
final class realm_sync_error extends ffi.Struct {
  external realm_error_t status;

  external ffi.Pointer<ffi.Char> c_original_file_path_key;

  external ffi.Pointer<ffi.Char> c_recovery_file_path_key;

  @ffi.Bool()
  external bool is_fatal;

  @ffi.Bool()
  external bool is_unrecognized_by_client;

  @ffi.Bool()
  external bool is_client_reset_requested;

  @ffi.Int32()
  external int server_requests_action;

  external ffi.Pointer<realm_sync_error_user_info_t> user_info_map;

  @ffi.Size()
  external int user_info_length;

  external ffi.Pointer<realm_sync_error_compensating_write_info_t> compensating_writes;

  @ffi.Size()
  external int compensating_writes_length;

  external ffi.Pointer<ffi.Void> user_code_error;
}

abstract class realm_sync_error_action {
  static const int RLM_SYNC_ERROR_ACTION_NO_ACTION = 0;
  static const int RLM_SYNC_ERROR_ACTION_PROTOCOL_VIOLATION = 1;
  static const int RLM_SYNC_ERROR_ACTION_APPLICATION_BUG = 2;
  static const int RLM_SYNC_ERROR_ACTION_WARNING = 3;
  static const int RLM_SYNC_ERROR_ACTION_TRANSIENT = 4;
  static const int RLM_SYNC_ERROR_ACTION_DELETE_REALM = 5;
  static const int RLM_SYNC_ERROR_ACTION_CLIENT_RESET = 6;
  static const int RLM_SYNC_ERROR_ACTION_CLIENT_RESET_NO_RECOVERY = 7;
  static const int RLM_SYNC_ERROR_ACTION_MIGRATE_TO_FLX = 8;
  static const int RLM_SYNC_ERROR_ACTION_REVERT_TO_PBS = 9;
}

final class realm_sync_error_compensating_write_info extends ffi.Struct {
  external ffi.Pointer<ffi.Char> reason;

  external ffi.Pointer<ffi.Char> object_name;

  external realm_value_t primary_key;
}

typedef realm_sync_error_compensating_write_info_t = realm_sync_error_compensating_write_info;
typedef realm_sync_error_handler_func_t = ffi.Pointer<ffi.NativeFunction<realm_sync_error_handler_func_tFunction>>;
typedef realm_sync_error_handler_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<realm_sync_session_t>, realm_sync_error_t);
typedef Dartrealm_sync_error_handler_func_tFunction = void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<realm_sync_session_t>, realm_sync_error_t);

/// This type should never be returned from a function.
/// It's only meant as an asynchronous callback argument.
/// Pointers to this struct and its pointer members are only valid inside the scope
/// of the callback they were passed to.
typedef realm_sync_error_t = realm_sync_error;

final class realm_sync_error_user_info extends ffi.Struct {
  external ffi.Pointer<ffi.Char> key;

  external ffi.Pointer<ffi.Char> value;
}

typedef realm_sync_error_user_info_t = realm_sync_error_user_info;
typedef realm_sync_on_subscription_state_changed_t = ffi.Pointer<ffi.NativeFunction<realm_sync_on_subscription_state_changed_tFunction>>;
typedef realm_sync_on_subscription_state_changed_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void> userdata, ffi.Int32 state);
typedef Dartrealm_sync_on_subscription_state_changed_tFunction = void Function(ffi.Pointer<ffi.Void> userdata, int state);
typedef realm_sync_on_user_state_changed_t = ffi.Pointer<ffi.NativeFunction<realm_sync_on_user_state_changed_tFunction>>;
typedef realm_sync_on_user_state_changed_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void> userdata, ffi.Int32 s);
typedef Dartrealm_sync_on_user_state_changed_tFunction = void Function(ffi.Pointer<ffi.Void> userdata, int s);

abstract class realm_sync_progress_direction {
  static const int RLM_SYNC_PROGRESS_DIRECTION_UPLOAD = 0;
  static const int RLM_SYNC_PROGRESS_DIRECTION_DOWNLOAD = 1;
}

typedef realm_sync_progress_func_t = ffi.Pointer<ffi.NativeFunction<realm_sync_progress_func_tFunction>>;
typedef realm_sync_progress_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void> userdata, ffi.Uint64 transferred_bytes, ffi.Uint64 total_bytes);
typedef Dartrealm_sync_progress_func_tFunction = void Function(ffi.Pointer<ffi.Void> userdata, int transferred_bytes, int total_bytes);

final class realm_sync_session extends ffi.Opaque {}

final class realm_sync_session_connection_state_notification_token extends ffi.Opaque {}

typedef realm_sync_session_connection_state_notification_token_t = realm_sync_session_connection_state_notification_token;

abstract class realm_sync_session_resync_mode {
  static const int RLM_SYNC_SESSION_RESYNC_MODE_MANUAL = 0;
  static const int RLM_SYNC_SESSION_RESYNC_MODE_DISCARD_LOCAL = 1;
  static const int RLM_SYNC_SESSION_RESYNC_MODE_RECOVER = 2;
  static const int RLM_SYNC_SESSION_RESYNC_MODE_RECOVER_OR_DISCARD = 3;
}

abstract class realm_sync_session_state {
  static const int RLM_SYNC_SESSION_STATE_ACTIVE = 0;
  static const int RLM_SYNC_SESSION_STATE_DYING = 1;
  static const int RLM_SYNC_SESSION_STATE_INACTIVE = 2;
  static const int RLM_SYNC_SESSION_STATE_WAITING_FOR_ACCESS_TOKEN = 3;
  static const int RLM_SYNC_SESSION_STATE_PAUSED = 4;
}

abstract class realm_sync_session_stop_policy {
  static const int RLM_SYNC_SESSION_STOP_POLICY_IMMEDIATELY = 0;
  static const int RLM_SYNC_SESSION_STOP_POLICY_LIVE_INDEFINITELY = 1;
  static const int RLM_SYNC_SESSION_STOP_POLICY_AFTER_CHANGES_UPLOADED = 2;
}

typedef realm_sync_session_t = realm_sync_session;

final class realm_sync_socket extends ffi.Opaque {}

final class realm_sync_socket_callback extends ffi.Opaque {}

abstract class realm_sync_socket_callback_result {
  /// These error values are pulled directly from realm_errno_e
  static const int RLM_ERR_SYNC_SOCKET_SUCCESS = 0;
  static const int RLM_ERR_SYNC_SOCKET_OPERATION_ABORTED = 1027;
  static const int RLM_ERR_SYNC_SOCKET_RUNTIME = 1000;
  static const int RLM_ERR_SYNC_SOCKET_OUT_OF_MEMORY = 1003;
  static const int RLM_ERR_SYNC_SOCKET_ADDRESS_SPACE_EXHAUSTED = 1005;
  static const int RLM_ERR_SYNC_SOCKET_CONNECTION_CLOSED = 1030;
  static const int RLM_ERR_SYNC_SOCKET_NOT_SUPPORTED = 2001;
  static const int RLM_ERR_SYNC_SOCKET_INVALID_ARGUMENT = 3000;
}

/// Called when the Sync Client is initiating a connection to the server. The endpoint
/// structure contains the server address/URL and the websocket_observer will need to
/// be stored locally in the WebSocket CAPI implementation so it can be used with the
/// realm_sync_socket_websocket_[connected|message|error|closed]() functions when
/// providing WebSocket status or data to the Sync Client.
typedef realm_sync_socket_connect_func_t = ffi.Pointer<ffi.NativeFunction<realm_sync_socket_connect_func_tFunction>>;
typedef realm_sync_socket_connect_func_tFunction = realm_sync_socket_websocket_t Function(
    ffi.Pointer<ffi.Void> userdata, realm_websocket_endpoint_t endpoint, ffi.Pointer<realm_websocket_observer_t> websocket_observer);

/// Called when a Sync Socket Timer is being created, which will start the timer countdown
/// immediately. The Timer CAPI implementation will need to be stored locally so it can
/// be used when calling realm_sync_socket_timer_complete() when the timer countdown
/// reaches 0 (i.e. expired) or realm_sync_socket_timer_canceled() when the timer is canceled.
/// The timer_callback pointer does not need to be released by the CAPI implementation.
typedef realm_sync_socket_create_timer_func_t = ffi.Pointer<ffi.NativeFunction<realm_sync_socket_create_timer_func_tFunction>>;
typedef realm_sync_socket_create_timer_func_tFunction = realm_sync_socket_timer_t Function(
    ffi.Pointer<ffi.Void> userdata, ffi.Uint64 delay_ms, ffi.Pointer<realm_sync_socket_timer_callback_t> timer_callback);
typedef Dartrealm_sync_socket_create_timer_func_tFunction = realm_sync_socket_timer_t Function(
    ffi.Pointer<ffi.Void> userdata, int delay_ms, ffi.Pointer<realm_sync_socket_timer_callback_t> timer_callback);
typedef realm_sync_socket_post_callback_t = realm_sync_socket_callback;

/// Called when the Sync Client posts a callback handler to be run within the context
/// of the event loop.
/// The post_callback pointer does not need to be released by the CAPI implementation.
typedef realm_sync_socket_post_func_t = ffi.Pointer<ffi.NativeFunction<realm_sync_socket_post_func_tFunction>>;
typedef realm_sync_socket_post_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_sync_socket_post_callback_t> post_callback);
typedef Dartrealm_sync_socket_post_func_tFunction = void Function(ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_sync_socket_post_callback_t> post_callback);

/// The following definitions are intended for internal state and structures
/// used by the Sync Client. These values should be retained by the Platform
/// Networking CAPI implementation so they can be provided back to the Platform
/// Networking CAPI functions.
typedef realm_sync_socket_t = realm_sync_socket;
typedef realm_sync_socket_timer_callback_t = realm_sync_socket_callback;

/// Called when a Sync Socket Timer has been explicitly canceled or the Timer is being
/// destroyed. Use the realm_sync_socket_timer_canceled() function to notify the Sync Client
/// that the timer cancel is complete. NOTE: This function will always be called before the
/// timer is destroyed (even if the timer has completed), but the timer callback should only
/// be executed one time.
typedef realm_sync_socket_timer_canceled_func_t = ffi.Pointer<ffi.NativeFunction<realm_sync_socket_timer_canceled_func_tFunction>>;
typedef realm_sync_socket_timer_canceled_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void> userdata, realm_sync_socket_timer_t timer_userdata);
typedef Dartrealm_sync_socket_timer_canceled_func_tFunction = void Function(ffi.Pointer<ffi.Void> userdata, realm_sync_socket_timer_t timer_userdata);

/// Called when the timer object has been destroyed so the Sync Socket Timer CAPI
/// implementation can clean up its timer resources.
typedef realm_sync_socket_timer_free_func_t = ffi.Pointer<ffi.NativeFunction<realm_sync_socket_timer_free_func_tFunction>>;
typedef realm_sync_socket_timer_free_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void> userdata, realm_sync_socket_timer_t timer_userdata);
typedef Dartrealm_sync_socket_timer_free_func_tFunction = void Function(ffi.Pointer<ffi.Void> userdata, realm_sync_socket_timer_t timer_userdata);
typedef realm_sync_socket_timer_t = ffi.Pointer<ffi.Void>;

/// Called by a connection in the Sync Client when it needs to send data to the server. The
/// write_callback is used with realm_sync_socket_write_complete() to inform the connection
/// that the data has been transferred successfully.
/// If an error occurs during the async write operation, it needs to be provided to the
/// write_callback handler, and the websocket is exepected to be closed by calling
/// realm_sync_socket_websocket_error() followed by providing the error code and reason to
/// realm_sync_socket_websocket_closed().
/// The write_callback pointer does not need to be released by the CAPI implementation.
typedef realm_sync_socket_websocket_async_write_func_t = ffi.Pointer<ffi.NativeFunction<realm_sync_socket_websocket_async_write_func_tFunction>>;
typedef realm_sync_socket_websocket_async_write_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void> userdata, realm_sync_socket_websocket_t websocket,
    ffi.Pointer<ffi.Char> data, ffi.Size size, ffi.Pointer<realm_sync_socket_write_callback_t> write_callback);
typedef Dartrealm_sync_socket_websocket_async_write_func_tFunction = void Function(ffi.Pointer<ffi.Void> userdata, realm_sync_socket_websocket_t websocket,
    ffi.Pointer<ffi.Char> data, int size, ffi.Pointer<realm_sync_socket_write_callback_t> write_callback);

/// Called when the websocket has been destroyed in the Sync Client - no more write callbacks or observer
/// functions should be called when this function is called.
typedef realm_sync_socket_websocket_free_func_t = ffi.Pointer<ffi.NativeFunction<realm_sync_socket_websocket_free_func_tFunction>>;
typedef realm_sync_socket_websocket_free_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void> userdata, realm_sync_socket_websocket_t websocket);
typedef Dartrealm_sync_socket_websocket_free_func_tFunction = void Function(ffi.Pointer<ffi.Void> userdata, realm_sync_socket_websocket_t websocket);
typedef realm_sync_socket_websocket_t = ffi.Pointer<ffi.Void>;
typedef realm_sync_socket_write_callback_t = realm_sync_socket_callback;
typedef realm_sync_ssl_verify_func_t = ffi.Pointer<ffi.NativeFunction<realm_sync_ssl_verify_func_tFunction>>;
typedef realm_sync_ssl_verify_func_tFunction = ffi.Bool Function(ffi.Pointer<ffi.Void> userdata, ffi.Pointer<ffi.Char> server_address, ffi.Short server_port,
    ffi.Pointer<ffi.Char> pem_data, ffi.Size pem_size, ffi.Int preverify_ok, ffi.Int depth);
typedef Dartrealm_sync_ssl_verify_func_tFunction = bool Function(ffi.Pointer<ffi.Void> userdata, ffi.Pointer<ffi.Char> server_address, int server_port,
    ffi.Pointer<ffi.Char> pem_data, int pem_size, int preverify_ok, int depth);

final class realm_sync_user_subscription_token extends ffi.Opaque {}

typedef realm_sync_user_subscription_token_t = realm_sync_user_subscription_token;

/// Callback function invoked by the sync session once it has uploaded or download
/// all available changesets. See @a realm_sync_session_wait_for_upload and
/// @a realm_sync_session_wait_for_download.
///
/// This callback is invoked on the sync client's worker thread.
///
/// @param error Null, if the operation completed successfully.
typedef realm_sync_wait_for_completion_func_t = ffi.Pointer<ffi.NativeFunction<realm_sync_wait_for_completion_func_tFunction>>;
typedef realm_sync_wait_for_completion_func_tFunction = ffi.Void Function(ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_error_t> error);
typedef Dartrealm_sync_wait_for_completion_func_tFunction = void Function(ffi.Pointer<ffi.Void> userdata, ffi.Pointer<realm_error_t> error);
typedef realm_t = shared_realm;

final class realm_thread_safe_reference extends ffi.Opaque {}

typedef realm_thread_safe_reference_t = realm_thread_safe_reference;

final class realm_timestamp extends ffi.Struct {
  @ffi.Int64()
  external int seconds;

  @ffi.Int32()
  external int nanoseconds;
}

typedef realm_timestamp_t = realm_timestamp;

final class realm_user extends ffi.Opaque {}

final class realm_user_identity extends ffi.Struct {
  /// Ptr to null terminated string representing user identity (memory has to be freed by SDK)
  external ffi.Pointer<ffi.Char> id;

  /// Enum representing the list of auth providers
  @ffi.Int32()
  external int provider_type;
}

typedef realm_user_identity_t = realm_user_identity;

abstract class realm_user_state {
  static const int RLM_USER_STATE_LOGGED_OUT = 0;
  static const int RLM_USER_STATE_LOGGED_IN = 1;
  static const int RLM_USER_STATE_REMOVED = 2;
}

typedef realm_user_t = realm_user;

final class realm_uuid extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> bytes;
}

typedef realm_uuid_t = realm_uuid;

final class realm_value extends ffi.Struct {
  external UnnamedUnion1 values;

  @ffi.Int32()
  external int type;
}

typedef realm_value_t = realm_value;

/// Value types
abstract class realm_value_type {
  static const int RLM_TYPE_NULL = 0;
  static const int RLM_TYPE_INT = 1;
  static const int RLM_TYPE_BOOL = 2;
  static const int RLM_TYPE_STRING = 3;
  static const int RLM_TYPE_BINARY = 4;
  static const int RLM_TYPE_TIMESTAMP = 5;
  static const int RLM_TYPE_FLOAT = 6;
  static const int RLM_TYPE_DOUBLE = 7;
  static const int RLM_TYPE_DECIMAL128 = 8;
  static const int RLM_TYPE_OBJECT_ID = 9;
  static const int RLM_TYPE_LINK = 10;
  static const int RLM_TYPE_UUID = 11;
}

final class realm_version_id extends ffi.Struct {
  @ffi.Uint64()
  external int version;

  @ffi.Uint64()
  external int index;
}

typedef realm_version_id_t = realm_version_id;

abstract class realm_web_socket_errno {
  static const int RLM_ERR_WEBSOCKET_OK = 1000;
  static const int RLM_ERR_WEBSOCKET_GOINGAWAY = 1001;
  static const int RLM_ERR_WEBSOCKET_PROTOCOLERROR = 1002;
  static const int RLM_ERR_WEBSOCKET_UNSUPPORTEDDATA = 1003;
  static const int RLM_ERR_WEBSOCKET_RESERVED = 1004;
  static const int RLM_ERR_WEBSOCKET_NOSTATUSRECEIVED = 1005;
  static const int RLM_ERR_WEBSOCKET_ABNORMALCLOSURE = 1006;
  static const int RLM_ERR_WEBSOCKET_INVALIDPAYLOADDATA = 1007;
  static const int RLM_ERR_WEBSOCKET_POLICYVIOLATION = 1008;
  static const int RLM_ERR_WEBSOCKET_MESSAGETOOBIG = 1009;
  static const int RLM_ERR_WEBSOCKET_INAVALIDEXTENSION = 1010;
  static const int RLM_ERR_WEBSOCKET_INTERNALSERVERERROR = 1011;
  static const int RLM_ERR_WEBSOCKET_TLSHANDSHAKEFAILED = 1015;
  static const int RLM_ERR_WEBSOCKET_UNAUTHORIZED = 4001;
  static const int RLM_ERR_WEBSOCKET_FORBIDDEN = 4002;
  static const int RLM_ERR_WEBSOCKET_MOVEDPERMANENTLY = 4003;
  static const int RLM_ERR_WEBSOCKET_CLIENT_TOO_OLD = 4004;
  static const int RLM_ERR_WEBSOCKET_CLIENT_TOO_NEW = 4005;
  static const int RLM_ERR_WEBSOCKET_PROTOCOL_MISMATCH = 4006;
  static const int RLM_ERR_WEBSOCKET_RESOLVE_FAILED = 4400;
  static const int RLM_ERR_WEBSOCKET_CONNECTION_FAILED = 4401;
  static const int RLM_ERR_WEBSOCKET_READ_ERROR = 4402;
  static const int RLM_ERR_WEBSOCKET_WRITE_ERROR = 4403;
  static const int RLM_ERR_WEBSOCKET_RETRY_ERROR = 4404;
  static const int RLM_ERR_WEBSOCKET_FATAL_ERROR = 4405;
}

/// Sync Socket Provider types
final class realm_websocket_endpoint extends ffi.Struct {
  /// Host address
  external ffi.Pointer<ffi.Char> address;

  /// Host port number
  @ffi.Uint16()
  external int port;

  /// Includes access token in query.
  external ffi.Pointer<ffi.Char> path;

  /// Array of one or more websocket protocols
  external ffi.Pointer<ffi.Pointer<ffi.Char>> protocols;

  /// Number of protocols in array
  @ffi.Size()
  external int num_protocols;

  /// true if SSL should be used
  @ffi.Bool()
  external bool is_ssl;
}

/// Sync Socket Provider types
typedef realm_websocket_endpoint_t = realm_websocket_endpoint;

final class realm_websocket_observer extends ffi.Opaque {}

typedef realm_websocket_observer_t = realm_websocket_observer;

final class realm_work_queue extends ffi.Opaque {}

typedef realm_work_queue_t = realm_work_queue;

final class shared_realm extends ffi.Opaque {}
